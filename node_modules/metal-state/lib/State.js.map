{"version":3,"sources":["../src/State.js"],"names":["State","config","obj","context","context_","keysBlacklist_","obj_","eventData_","scheduledBatchData_","stateInfo_","stateConfigs_","initialValues_","mixin","setShouldUseFacade","configStateFromStaticHint_","Object","defineProperty","STATE_REF_KEY","configurable","enumerable","value","name","required","info","getStateInfo","state","KeyStates","INITIALIZED","get","errorMessage","shouldThrowValidationError","Error","console","error","validatorReturn","getStateKeyValue_","set","val","setStateKeyValue_","fn","args","apply","currentValue","setter","callFunction_","validator","assertValidatorReturnInstanceOfError_","writeOnce","written","configs","names","keys","length","props","i","assertValidStateKeyName_","buildKeyPropertyDef_","defineProperties","assertGivenIfRequired_","validateInitialValue_","ctor","constructor","defineContext","staticKey","STATE_STATIC_HINT_CONFIGURED","prototype","configState","getStateStatic","isDisposed","emit","data","getStateKeys","warnIfDisposed_","initStateKey_","hasInitialValue_","hasOwnProperty","key","prevVal","shouldInformChange_","newVal","scheduleBatchEvent_","UNINITIALIZED","INITIALIZING","setInitialValue_","setDefaultValue","changeData","nextTick","emitBatchEvent_","changes","hasStateKey","undefined","valueFn","blacklist","values","callback","forEach","once","canSetState","validateKeyValue_","callSetter_","informChange_","callValidator_","disposed","warn","mergeState","mergedVal","currVal"],"mappings":"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","file":"State.js","sourcesContent":["'use strict';\n\nimport {\n\tasync,\n\tgetStaticProperty,\n\tisDef,\n\tisDefAndNotNull,\n\tisFunction,\n\tisObject,\n\tisString,\n\tobject,\n} from 'metal';\nimport {EventEmitter} from 'metal-events';\n\n/**\n * State adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `configState` method for a complete list of available configuration\n * options for each state key.\n * @extends {EventEmitter}\n */\nclass State extends EventEmitter {\n\t/**\n\t * Constructor function for `State`.\n\t * @param {Object=} config Optional config object with initial values to\n\t *     set state properties to.\n\t * @param {Object=} obj Optional object that should hold the state\n\t *     properties. If none is given, they will be added directly to `this`\n\t *     instead.\n\t * @param {Object=} context Optional context to call functions (like\n\t *     validators and setters) on. Defaults to `this`.\n\t */\n\tconstructor(config, obj, context) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Context to call functions (like validators and setters) on.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.context_ = context || this;\n\n\t\t/**\n\t\t * Map of keys that can not be used as state keys.\n\t\t * @type {Object<string, boolean>}\n\t\t * @protected\n\t\t */\n\t\tthis.keysBlacklist_ = null;\n\n\t\t/**\n\t\t * Object that should hold the state properties.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.obj_ = obj || this;\n\n\t\tthis.eventData_ = null;\n\n\t\t/**\n\t\t * Object with information about the batch event that is currently\n\t\t * scheduled, or null if none is.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledBatchData_ = null;\n\n\t\t/**\n\t\t * Object that contains information about all this instance's state keys.\n\t\t * @type {!Object<string, !Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.stateInfo_ = {};\n\n\t\tthis.stateConfigs_ = {};\n\n\t\tthis.initialValues_ = object.mixin({}, config);\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.configStateFromStaticHint_();\n\n\t\tObject.defineProperty(this.obj_, State.STATE_REF_KEY, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: this,\n\t\t});\n\t}\n\n\t/**\n\t * Logs an error if the given property is required but wasn't given.\n\t * @param {string} name\n\t * @protected\n\t */\n\tassertGivenIfRequired_(name) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.required) {\n\t\t\tconst info = this.getStateInfo(name);\n\t\t\tconst value =\n\t\t\t\tinfo.state === State.KeyStates.INITIALIZED\n\t\t\t\t\t? this.get(name)\n\t\t\t\t\t: this.initialValues_[name];\n\t\t\tif (!isDefAndNotNull(value)) {\n\t\t\t\tlet errorMessage = `The property called \"${\n\t\t\t\t\tname\n\t\t\t\t}\" is required but didn't receive a value.`;\n\t\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Logs an error if the `validatorReturn` is instance of `Error`.\n\t * @param {*} validatorReturn\n\t * @protected\n\t */\n\tassertValidatorReturnInstanceOfError_(validatorReturn) {\n\t\tif (validatorReturn instanceof Error) {\n\t\t\tif (this.shouldThrowValidationError()) {\n\t\t\t\tthrow validatorReturn;\n\t\t\t} else {\n\t\t\t\tconsole.error(`Warning: ${validatorReturn}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the given name is a valid state key name. If it's not, an error\n\t * will be thrown.\n\t * @param {string} name The name to be validated.\n\t * @throws {Error}\n\t * @protected\n\t */\n\tassertValidStateKeyName_(name) {\n\t\tif (this.keysBlacklist_ && this.keysBlacklist_[name]) {\n\t\t\tthrow new Error(\n\t\t\t\t`It's not allowed to create a state key with the name \"${\n\t\t\t\t\tname\n\t\t\t\t}\".`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the property definition object for the specified state key.\n\t * @param {string} name The name of the key.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tbuildKeyPropertyDef_(name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn this[State.STATE_REF_KEY].getStateKeyValue_(name);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis[State.STATE_REF_KEY].setStateKeyValue_(name, val);\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Calls the requested function, running the appropriate code for when it's\n\t * passed as an actual function object or just the function's name.\n\t * @param {!Function|string} fn Function, or name of the function to run.\n\t * @param {!Array} args optional array of parameters to be passed to the\n\t *   function that will be called.\n\t * @return {*} The return value of the called function.\n\t * @protected\n\t */\n\tcallFunction_(fn, args) {\n\t\tif (isString(fn)) {\n\t\t\treturn this.context_[fn].apply(this.context_, args); // eslint-disable-line\n\t\t} else if (isFunction(fn)) {\n\t\t\treturn fn.apply(this.context_, args);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the state key's setter, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be set.\n\t * @param {*} currentValue The current value.\n\t * @return {*} The final value to be set.\n\t * @protected\n\t */\n\tcallSetter_(name, value, currentValue) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.setter) {\n\t\t\tvalue = this.callFunction_(config.setter, [value, currentValue]);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Calls the state key's validator, if there is one. Emits console\n\t * warning if validator returns a string.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tcallValidator_(name, value) {\n\t\tconst config = this.stateConfigs_[name];\n\t\tif (config.validator) {\n\t\t\tconst validatorReturn = this.callFunction_(config.validator, [\n\t\t\t\tvalue,\n\t\t\t\tname,\n\t\t\t\tthis.context_,\n\t\t\t]);\n\t\t\tthis.assertValidatorReturnInstanceOfError_(validatorReturn);\n\t\t\treturn validatorReturn;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the it's allowed to write on the requested state key.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\tcanSetState(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn !this.stateConfigs_[name].writeOnce || !info.written;\n\t}\n\n\t/**\n\t * Adds the given key(s) to the state, together with its(their) configs.\n\t * Config objects support the given settings:\n\t *     required - When set to `true`, causes errors to be printed (via\n\t *     `console.error`) if no value is given for the property.\n\t *\n\t *     setter - Function for normalizing state key values. It receives the new\n\t *     value that was set, and returns the value that should be stored.\n\t *\n\t *     validator - Function that validates state key values. When it returns\n\t *     false, the new value is ignored. When it returns an instance of Error,\n\t *     it will emit the error to the console.\n\t *\n\t *     value - The default value for the state key. Note that setting this to\n\t *     an object will cause all class instances to use the same reference to\n\t *     the object. To have each instance use a different reference for objects,\n\t *     use the `valueFn` option instead.\n\t *\n\t *     valueFn - A function that returns the default value for a state key.\n\t *\n\t *     writeOnce - Ignores writes to the state key after it's been first\n\t *     written to. That is, allows writes only when setting the value for the\n\t *     first time.\n\t * @param {!Object.<string, !Object>|string} configs An object that maps\n\t *     configuration options for keys to be added to the state.\n\t * @param {boolean|Object|*=} context The context where the added state\n\t *     keys will be defined (defaults to `this`), or false if they shouldn't\n\t *     be defined at all.\n\t */\n\tconfigState(configs, context) {\n\t\tconst names = Object.keys(configs);\n\t\tif (names.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (context !== false) {\n\t\t\tconst props = {};\n\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\tconst name = names[i];\n\t\t\t\tthis.assertValidStateKeyName_(name);\n\t\t\t\tprops[name] = this.buildKeyPropertyDef_(name);\n\t\t\t}\n\t\t\tObject.defineProperties(context || this.obj_, props);\n\t\t}\n\n\t\tthis.stateConfigs_ = configs;\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tconst name = names[i];\n\t\t\tconfigs[name] = configs[name].config\n\t\t\t\t? configs[name].config\n\t\t\t\t: configs[name];\n\t\t\tthis.assertGivenIfRequired_(names[i]);\n\t\t\tthis.validateInitialValue_(names[i]);\n\t\t}\n\t}\n\n\t/**\n\t * Adds state keys from super classes static hint `MyClass.STATE = {};`.\n\t * @protected\n\t */\n\tconfigStateFromStaticHint_() {\n\t\tconst ctor = this.constructor;\n\t\tif (ctor !== State) {\n\t\t\tlet defineContext;\n\t\t\tif (this.obj_ === this) {\n\t\t\t\tconst staticKey = State.STATE_STATIC_HINT_CONFIGURED;\n\n\t\t\t\tctor[staticKey] = ctor[staticKey] || {};\n\n\t\t\t\tdefineContext = ctor[staticKey][ctor.name]\n\t\t\t\t\t? false\n\t\t\t\t\t: ctor.prototype; // eslint-disable-line\n\t\t\t\tctor[staticKey][ctor.name] = true;\n\t\t\t}\n\t\t\tthis.configState(State.getStateStatic(ctor), defineContext);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.initialValues_ = null;\n\t\tthis.stateInfo_ = null;\n\t\tthis.stateConfigs_ = null;\n\t\tthis.scheduledBatchData_ = null;\n\t}\n\n\t/**\n\t * Emits the state change batch event.\n\t * @protected\n\t */\n\temitBatchEvent_() {\n\t\tif (!this.isDisposed()) {\n\t\t\tthis.context_.emit('stateWillChange', this.scheduledBatchData_);\n\n\t\t\tconst data = this.scheduledBatchData_;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t\tthis.context_.emit('stateChanged', data);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the requested state key.\n\t * Note: this can and should be accomplished by accessing the value as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this.obj_[name];\n\t}\n\n\t/**\n\t * Returns an object that maps state keys to their values.\n\t * @param {Array<string>=} names A list of names of the keys that should\n\t *   be returned. If none is given, the whole state will be returned.\n\t * @return {Object.<string, *>}\n\t */\n\tgetState(names = this.getStateKeys()) {\n\t\tconst state = {};\n\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tstate[names[i]] = this.get(names[i]);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Gets information about the specified state property.\n\t * @param {string} name\n\t * @return {!Object}\n\t */\n\tgetStateInfo(name) {\n\t\tif (!this.stateInfo_[name]) {\n\t\t\tthis.stateInfo_[name] = {};\n\t\t}\n\t\treturn this.stateInfo_[name];\n\t}\n\n\t/**\n\t * Gets the config object for the requested state key.\n\t * @param {string} name The key's name.\n\t * @return {Object}\n\t * @protected\n\t */\n\tgetStateKeyConfig(name) {\n\t\treturn this.stateConfigs_ ? this.stateConfigs_[name] : null;\n\t}\n\n\t/**\n\t * Returns an array with all state keys.\n\t * @return {!Array.<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];\n\t}\n\n\t/**\n\t * Gets the value of the specified state key. This is passed as that key's\n\t * getter to the `Object.defineProperty` call inside the `addKeyToState` method.\n\t * @param {string} name The name of the key.\n\t * @return {*}\n\t * @protected\n\t */\n\tgetStateKeyValue_(name) {\n\t\tif (!this.warnIfDisposed_(name)) {\n\t\t\tthis.initStateKey_(name);\n\t\t\treturn this.getStateInfo(name).value;\n\t\t}\n\t}\n\n\t/**\n\t * Merges the STATE static variable for the given constructor function.\n\t * @param  {!Function} ctor Constructor function.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t * @static\n\t */\n\tstatic getStateStatic(ctor) {\n\t\treturn getStaticProperty(ctor, 'STATE', State.mergeState);\n\t}\n\n\t/**\n\t * Checks if the value of the state key with the given name has already been\n\t * set. Note that this doesn't run the key's getter.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t */\n\thasBeenSet(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn (\n\t\t\tinfo.state === State.KeyStates.INITIALIZED ||\n\t\t\tthis.hasInitialValue_(name) // eslint-disable-line\n\t\t);\n\t}\n\n\t/**\n\t * Checks if an initial value was given to the specified state property.\n\t * @param {string} name The name of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\thasInitialValue_(name) {\n\t\treturn (\n\t\t\tthis.initialValues_.hasOwnProperty(name) &&\n\t\t\tisDef(this.initialValues_[name])\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the given key is present in this instance's state.\n\t * @param {string} key\n\t * @return {boolean}\n\t */\n\thasStateKey(key) {\n\t\tif (!this.warnIfDisposed_(key)) {\n\t\t\treturn !!this.stateConfigs_[key];\n\t\t}\n\t}\n\n\t/**\n\t * Informs of changes to a state key's value through an event. Won't trigger\n\t * the event if the value hasn't changed or if it's being initialized.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @protected\n\t */\n\tinformChange_(name, prevVal) {\n\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\tconst data = object.mixin(\n\t\t\t\t{\n\t\t\t\t\tkey: name,\n\t\t\t\t\tnewVal: this.get(name),\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t},\n\t\t\t\tthis.eventData_\n\t\t\t);\n\t\t\tthis.context_.emit(`${name}Changed`, data);\n\t\t\tthis.context_.emit('stateKeyChanged', data);\n\t\t\tthis.scheduleBatchEvent_(data);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the specified state key, giving it a first value.\n\t * @param {string} name The name of the key.\n\t * @protected\n\t */\n\tinitStateKey_(name) {\n\t\tconst info = this.getStateInfo(name);\n\t\tif (info.state !== State.KeyStates.UNINITIALIZED) {\n\t\t\treturn;\n\t\t}\n\n\t\tinfo.state = State.KeyStates.INITIALIZING;\n\t\tthis.setInitialValue_(name);\n\t\tif (!info.written) {\n\t\t\tthis.setDefaultValue(name);\n\t\t}\n\t\tinfo.state = State.KeyStates.INITIALIZED;\n\t}\n\n\t/**\n\t * Merges two values for the STATE property into a single object.\n\t * @param {Object} mergedVal\n\t * @param {Object} currVal\n\t * @return {!Object} The merged value.\n\t * @static\n\t */\n\tstatic mergeState(mergedVal, currVal) {\n\t\treturn object.mixin({}, currVal, mergedVal);\n\t}\n\n\t/**\n\t * Removes the requested state key.\n\t * @param {string} name The name of the key.\n\t */\n\tremoveStateKey(name) {\n\t\tthis.stateInfo_[name] = null;\n\t\tthis.stateConfigs_[name] = null;\n\t\tdelete this.obj_[name];\n\t}\n\n\t/**\n\t * Schedules a state change batch event to be emitted asynchronously.\n\t * @param {!Object} changeData Information about a state key's update.\n\t * @protected\n\t */\n\tscheduleBatchEvent_(changeData) {\n\t\tif (!this.scheduledBatchData_) {\n\t\t\tasync.nextTick(this.emitBatchEvent_, this);\n\t\t\tthis.scheduledBatchData_ = object.mixin(\n\t\t\t\t{\n\t\t\t\t\tchanges: {},\n\t\t\t\t},\n\t\t\t\tthis.eventData_\n\t\t\t);\n\t\t}\n\n\t\tconst name = changeData.key;\n\t\tconst changes = this.scheduledBatchData_.changes;\n\t\tif (changes[name]) {\n\t\t\tchanges[name].newVal = changeData.newVal;\n\t\t} else {\n\t\t\tchanges[name] = changeData;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the requested state key.\n\t * Note: this can and should be accomplished by setting the state key as a\n\t * regular property. This should only be used in cases where a function is\n\t * actually needed.\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tset(name, value) {\n\t\tif (this.hasStateKey(name)) {\n\t\t\tthis.obj_[name] = value;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default value of the requested state key.\n\t * @param {string} name The name of the key.\n\t */\n\tsetDefaultValue(name) {\n\t\tconst config = this.stateConfigs_[name];\n\n\t\tif (config.value !== undefined) {\n\t\t\tthis.set(name, config.value);\n\t\t} else {\n\t\t\tthis.set(name, this.callFunction_(config.valueFn));\n\t\t}\n\t}\n\n\t/**\n\t * Sets data to be sent with all events emitted from this instance.\n\t * @param {Object} data\n\t */\n\tsetEventData(data) {\n\t\tthis.eventData_ = data;\n\t}\n\n\t/**\n\t * Sets the initial value of the requested state key.\n\t * @param {string} name The name of the key.\n\t * @protected\n\t */\n\tsetInitialValue_(name) {\n\t\tif (this.hasInitialValue_(name)) {\n\t\t\tthis.set(name, this.initialValues_[name]);\n\t\t\tthis.initialValues_[name] = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Sets a map of keys that are not valid state keys.\n\t * @param {!Object<string, boolean>} blacklist\n\t */\n\tsetKeysBlacklist(blacklist) {\n\t\tthis.keysBlacklist_ = blacklist;\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} values A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(values, callback) {\n\t\tObject.keys(values).forEach(name => this.set(name, values[name]));\n\t\tif (callback && this.scheduledBatchData_) {\n\t\t\tthis.context_.once('stateChanged', callback);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the specified state key. This is passed as that key's\n\t * setter to the `Object.defineProperty` call inside the `addKeyToState`\n\t * method.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The new value of the key.\n\t * @protected\n\t */\n\tsetStateKeyValue_(name, value) {\n\t\tif (\n\t\t\tthis.warnIfDisposed_(name) ||\n\t\t\t!this.canSetState(name) ||\n\t\t\t!this.validateKeyValue_(name, value)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst prevVal = this.get(name);\n\t\tconst info = this.getStateInfo(name);\n\t\tinfo.value = this.callSetter_(name, value, prevVal);\n\t\tthis.assertGivenIfRequired_(name);\n\t\tinfo.written = true;\n\t\tthis.informChange_(name, prevVal);\n\t}\n\n\t/**\n\t * Checks if we should inform about a state update. Updates are ignored during\n\t * state initialization. Otherwise, updates to primitive values are only\n\t * informed when the new value is different from the previous one. Updates to\n\t * objects (which includes functions and arrays) are always informed outside\n\t * initialization though, since we can't be sure if all of the internal data\n\t * has stayed the same.\n\t * @param {string} name The name of the key.\n\t * @param {*} prevVal The previous value of the key.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldInformChange_(name, prevVal) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn (\n\t\t\tinfo.state === State.KeyStates.INITIALIZED &&\n\t\t\t(isObject(prevVal) || prevVal !== this.get(name))\n\t\t);\n\t}\n\n\t/**\n\t * Returns a boolean that determines whether or not should throw error when\n\t * vaildator functions returns an `Error` instance.\n\t * @return {boolean} By default returns false.\n\t */\n\tshouldThrowValidationError() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validates the initial value for the state property with the given name.\n\t * @param {string} name\n\t * @protected\n\t */\n\tvalidateInitialValue_(name) {\n\t\tif (\n\t\t\tthis.initialValues_.hasOwnProperty(name) &&\n\t\t\t!this.callValidator_(name, this.initialValues_[name])\n\t\t) {\n\t\t\tdelete this.initialValues_[name];\n\t\t}\n\t}\n\n\t/**\n\t * Validates the state key's value, which includes calling the validator\n\t * defined in the key's configuration object, if there is one.\n\t * @param {string} name The name of the key.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t * @protected\n\t */\n\tvalidateKeyValue_(name, value) {\n\t\tconst info = this.getStateInfo(name);\n\t\treturn (\n\t\t\tinfo.state === State.KeyStates.INITIALIZING ||\n\t\t\tthis.callValidator_(name, value)\n\t\t);\n\t}\n\n\t/**\n\t * Warns if this instance has already been disposed.\n\t * @param {string} name Name of the property to be accessed if not disposed.\n\t * @return {boolean} True if disposed, or false otherwise.\n\t * @protected\n\t */\n\twarnIfDisposed_(name) {\n\t\tconst disposed = this.isDisposed();\n\t\tif (disposed) {\n\t\t\tconsole.warn(\n\t\t\t\t`Error. Trying to access property \"${\n\t\t\t\t\tname\n\t\t\t\t}\" on disposed instance`\n\t\t\t);\n\t\t}\n\t\treturn disposed;\n\t}\n}\n\n/**\n * Constant used as key on State instance for storing property definition.\n * @type {!string}\n */\nState.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';\n\n/**\n * Constant used as key on class constructors that extend from State, stores\n * which constructors have had their static STATE configured so that\n * configuration of STATE is not repeated.\n * @type {!string}\n */\nState.STATE_STATIC_HINT_CONFIGURED = '__METAL_STATE_STATIC_HINT_CONFIGURED__';\n\n/**\n * Constants that represent the states that a state key can be in.\n * @type {!Object}\n */\nState.KeyStates = {\n\tUNINITIALIZED: undefined,\n\tINITIALIZING: 1,\n\tINITIALIZED: 2,\n};\n\nexport default State;\n"]}