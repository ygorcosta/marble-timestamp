{"version":3,"sources":["../src/validators.js"],"names":["ERROR_OBJECT_OF_TYPE","ERROR_ONE_OF","ERROR_ONE_OF_TYPE","validators","any","array","buildTypeValidator","bool","func","number","object","string","arrayOf","validator","isInvalid","throwConfigError","maybe","value","name","context","result","validateArrayItems","inRange","min","max","minResult","maxResult","valueResult","instanceOf","expectedClass","msg","composeError","objectOf","key","oneOf","arrayOfValues","indexOf","composeOneOfErrorMessage","oneOfType","arrayOfTypeValidators","i","length","shapeOf","shape","Object","prototype","hasOwnProperty","call","required","config","expectedType","validatorFn","validateType","bind","error","compName","constructor","renderer","getRenderer","parent","getParent","parentName","location","Error","JSON","stringify","getType","Array","isArray","typeValidator","type","itemValidatorError","errorMessage"],"mappings":"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","file":"validators.js","sourcesContent":["'use strict';\n\nimport {getFunctionName, isDefAndNotNull} from 'metal';\n\nconst ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';\nconst ERROR_ONE_OF = 'Expected one of the following values:';\nconst ERROR_ONE_OF_TYPE = 'Expected one of given types.';\n\n/**\n * Provides access to various type validators that will return an\n * instance of Error when validation fails. Note that all type validators\n * will also accept null or undefined values. To not accept these you should\n * instead make your state property required.\n */\nconst validators = {\n\tany: () => () => true,\n\tarray: buildTypeValidator('array'),\n\tbool: buildTypeValidator('boolean'),\n\tfunc: buildTypeValidator('function'),\n\tnumber: buildTypeValidator('number'),\n\tobject: buildTypeValidator('object'),\n\tstring: buildTypeValidator('string'),\n\n\t/**\n\t * Creates a validator that checks that the value it receives is an array\n\t * of items, and that all of the items pass the given validator.\n\t * @param {!function()} validator Validator to check each item against.\n\t * @return {!function()}\n\t */\n\tarrayOf: function(validator) {\n\t\tif (isInvalid(validators.func(validator))) {\n\t\t\tthrowConfigError('function', validator, 'arrayOf');\n\t\t}\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(value, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn validateArrayItems(validator, value, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks for a value within a range.\n\t * @param {!Number} min The minimum value allowed.\n\t * @param {!Number} max The maximum value allowed.\n\t * @return {!function()}\n\t */\n\tinRange: function(min, max) {\n\t\tconst minResult = validators.number(min);\n\t\tconst maxResult = validators.number(max);\n\t\tif (isInvalid(minResult)) {\n\t\t\treturn minResult;\n\t\t}\n\t\tif (isInvalid(maxResult)) {\n\t\t\treturn maxResult;\n\t\t}\n\t\treturn maybe(value => {\n\t\t\tconst valueResult = validators.number(value);\n\t\t\tif (isInvalid(valueResult)) {\n\t\t\t\treturn valueResult;\n\t\t\t}\n\t\t\treturn value >= min && value <= max;\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if a value is an instance of a given class.\n\t * @param {!function()} expectedClass Class to check value against.\n\t * @return {!function()}\n\t */\n\tinstanceOf: function(expectedClass) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tif (value instanceof expectedClass) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst msg = `Expected instance of ${expectedClass}`;\n\t\t\treturn composeError(msg, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks that the value it receives is an object,\n\t * and that all values within that object pass the given validator.\n\t * @param {!function()} validator Validator to check each object value against.\n\t * @return {!function()}\n\t */\n\tobjectOf: function(validator) {\n\t\tif (isInvalid(validators.func(validator))) {\n\t\t\tthrowConfigError('function', validator, 'objectOf');\n\t\t}\n\t\treturn maybe((value, name, context) => {\n\t\t\tfor (let key in value) {\n\t\t\t\tif (isInvalid(validator(value[key]))) {\n\t\t\t\t\treturn composeError(ERROR_OBJECT_OF_TYPE, name, context);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value matches one of the\n\t * given values.\n\t * @param {!Array} arrayOfValues Array of values to check equality against.\n\t * @return {!function()}\n\t */\n\toneOf: function(arrayOfValues) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(arrayOfValues, name, context);\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn arrayOfValues.indexOf(value) === -1\n\t\t\t\t? composeError(\n\t\t\t\t\tcomposeOneOfErrorMessage(arrayOfValues),\n\t\t\t\t\tname,\n\t\t\t\t\tcontext\n\t\t\t\t\t) // eslint-disable-line\n\t\t\t\t: true;\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value matches one of the\n\t * given types.\n\t * @param {!Array} arrayOfTypeValidators Array of validators to check value\n\t *     against.\n\t * @return {!function()}\n\t */\n\toneOfType: function(arrayOfTypeValidators) {\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst result = validators.array(\n\t\t\t\tarrayOfTypeValidators,\n\t\t\t\tname,\n\t\t\t\tcontext\n\t\t\t); // eslint-disable-line\n\t\t\tif (isInvalid(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < arrayOfTypeValidators.length; i++) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tif (\n\t\t\t\t\t!isInvalid(arrayOfTypeValidators[i](value, name, context))\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn composeError(ERROR_ONE_OF_TYPE, name, context);\n\t\t});\n\t},\n\n\t/**\n\t * Creates a validator that checks if the received value is an object, and\n\t * that its contents match the given shape.\n\t * @param {!Object} shape An object containing validators for each key.\n\t * @return {!function()}\n\t */\n\tshapeOf: function(shape) {\n\t\tif (isInvalid(validators.object(shape))) {\n\t\t\tthrowConfigError('object', shape, 'shapeOf');\n\t\t}\n\t\treturn maybe((value, name, context) => {\n\t\t\tconst valueResult = validators.object(value, name, context);\n\t\t\tif (isInvalid(valueResult)) {\n\t\t\t\treturn valueResult;\n\t\t\t}\n\t\t\tfor (let key in shape) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(shape, key)) {\n\t\t\t\t\tlet validator = shape[key];\n\t\t\t\t\tlet required = false;\n\t\t\t\t\tif (validator.config) {\n\t\t\t\t\t\trequired = validator.config.required;\n\t\t\t\t\t\tvalidator = validator.config.validator;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t(required && !isDefAndNotNull(value[key])) ||\n\t\t\t\t\t\tisInvalid(validator(value[key]))\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn validator(value[key], `${name}.${key}`, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t},\n};\n\n/**\n * Creates a validator that checks against a specific primitive type.\n * @param {string} expectedType Type to check against.\n * @return {!function()} Function that runs the validator if called with\n *     arguments, or just returns it otherwise. This means that when using a\n *     type validator in `State` it may be just passed directly (like\n *     `validators.bool`), or called with no args (like `validators.bool()`).\n *     That's done to allow all validators to be used consistently, since some\n *     (like `arrayOf`) always require that you call the function before\n *     receiving the actual validator. Type validators don't need the call, but\n *     work if it's made anyway.\n */\nfunction buildTypeValidator(expectedType) {\n\tconst validatorFn = maybe(validateType.bind(null, expectedType));\n\treturn (...args) => {\n\t\tif (args.length === 0) {\n\t\t\treturn validatorFn;\n\t\t} else {\n\t\t\treturn validatorFn(...args);\n\t\t}\n\t};\n}\n\n/**\n * Composes a warning a warning message.\n * @param {string} error Error message to display to console.\n * @param {?string} name Name of state property that is giving the error.\n * @param {Object} context The property's owner.\n * @return {!Error}\n */\nfunction composeError(error, name, context) {\n\tconst compName = context ? getFunctionName(context.constructor) : null;\n\tconst renderer = context && context.getRenderer && context.getRenderer();\n\tconst parent = renderer && renderer.getParent && renderer.getParent();\n\tconst parentName = parent ? getFunctionName(parent.constructor) : null;\n\tconst location = parentName\n\t\t? `Check render method of '${parentName}'.`\n\t\t: '';\n\treturn new Error(\n\t\t`Invalid state passed to '${name}'.` +\n\t\t\t` ${error} Passed to '${compName}'. ${location}`\n\t);\n}\n\n/**\n * Composes an error message for Config.oneOf validator.\n * @param {!Array} arrayOfValues Array of values to check equality against.\n * @return {!Error}\n */\nfunction composeOneOfErrorMessage(arrayOfValues) {\n\treturn `${ERROR_ONE_OF} ${JSON.stringify(arrayOfValues)}.`;\n}\n\n/**\n * Returns the type of the given value.\n * @param {*} value Any value.\n * @return {string} Type of value.\n */\nfunction getType(value) {\n\treturn Array.isArray(value) ? 'array' : typeof value;\n}\n\n/**\n * Checks if the given validator result says that the value is invalid.\n * @param {boolean|!Error} result\n * @return {boolean}\n */\nfunction isInvalid(result) {\n\treturn result instanceof Error;\n}\n\n/**\n * Wraps the given validator so that it also accepts null/undefined values.\n *   a validator that checks a value against a single type, null, or\n * undefined.\n * @param {!function()} typeValidator Validator to wrap.\n * @return {!function()} Wrapped validator.\n */\nfunction maybe(typeValidator) {\n\treturn (value, name, context) => {\n\t\treturn isDefAndNotNull(value)\n\t\t\t? typeValidator(value, name, context)\n\t\t\t: true; // eslint-disable-line\n\t};\n}\n\n/**\n * Throws error if validator is invoked with incorrect type.\n * @param {string} expectedType String representing the expected type.\n * @param {*} value The value to match the type of.\n * @param {!string} name Name of the function the validator is intended for.\n */\nfunction throwConfigError(expectedType, value, name) {\n\tconst type = getType(value);\n\tthrow new Error(\n\t\t`Expected type ${expectedType}, but received type ${type}. passed to ${\n\t\t\tname\n\t\t}.`\n\t);\n}\n\n/**\n * Checks if all the items of the given array pass the given validator.\n * @param {!function()} validator\n * @param {*} value The array to validate items for.\n * @param {string} name The name of the array property being checked.\n * @param {!Object} context Owner of the array property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateArrayItems(validator, value, name, context) {\n\tfor (let i = 0; i < value.length; i++) {\n\t\tif (isInvalid(validator(value[i], name, context))) {\n\t\t\tlet itemValidatorError = validator(value[i], name, context);\n\t\t\tlet errorMessage = `Validator for ${name}[${i}] says: \"${\n\t\t\t\titemValidatorError\n\t\t\t}\"`;\n\t\t\treturn composeError(errorMessage, name, context);\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Checks if the given value matches the expected type.\n * @param {string} expectedType String representing the expected type.\n * @param {*} value The value to match the type of.\n * @param {string} name The name of the property being checked.\n * @param {!Object} context Owner of the property being checked.\n * @return {!Error|boolean} `true` if the type matches, or an error otherwise.\n */\nfunction validateType(expectedType, value, name, context) {\n\tconst type = getType(value);\n\tif (type !== expectedType) {\n\t\tconst msg = `Expected type '${expectedType}', but received type '${\n\t\t\ttype\n\t\t}'.`;\n\t\treturn composeError(msg, name, context);\n\t}\n\treturn true;\n}\n\nexport default validators;\n"]}