{"version":3,"sources":["../src/SoyAop.js"],"names":["SoyAop","interceptFns_","getOriginalFn","fn","originalFn","handleTemplateCall_","data","ignored","ijData","interceptFn","length","call","registerForInterception","templates","name","bind","startInterception","push","stopAllInterceptions","stopInterception","pop"],"mappings":"AAAA;;;;;AAEA,IAAMA,SAAS;AACd;;;;;;;AAOAC,gBAAe,EARD;;AAUd;;;;;;AAMAC,gBAAe,uBAASC,EAAT,EAAa;AAC3B,SAAOA,GAAGC,UAAH,GAAgBD,GAAGC,UAAnB,GAAgCD,EAAvC;AACA,EAlBa;;AAoBd;;;;;;;;;;;AAWAE,sBAAqB,6BAASD,UAAT,EAAqBE,IAArB,EAA2BC,OAA3B,EAAoCC,MAApC,EAA4C;AAChE,MAAMC,cACLT,OAAOC,aAAP,CAAqBD,OAAOC,aAAP,CAAqBS,MAArB,GAA8B,CAAnD,CADD,CADgE,CAER;AACxD,MAAID,WAAJ,EAAiB;AAChB,UAAOA,YAAYE,IAAZ,CAAiB,IAAjB,EAAuBP,UAAvB,EAAmCE,IAAnC,EAAyCC,OAAzC,EAAkDC,MAAlD,CAAP;AACA,GAFD,MAEO;AACN,UAAOJ,WAAWO,IAAX,CAAgB,IAAhB,EAAsBL,IAAtB,EAA4BC,OAA5B,EAAqCC,MAArC,CAAP;AACA;AACD,EAvCa;;AAyCd;;;;;;AAMAI,0BAAyB,iCAASC,SAAT,EAAoBC,IAApB,EAA0B;AAClD,MAAMV,aAAaS,UAAUC,IAAV,CAAnB;AACA,MAAI,CAACV,WAAWA,UAAhB,EAA4B;AAC3BS,aAAUC,IAAV,IAAkBd,OAAOK,mBAAP,CAA2BU,IAA3B,CAAgC,IAAhC,EAAsCX,UAAtC,CAAlB;AACAS,aAAUC,IAAV,EAAgBV,UAAhB,GAA6BA,UAA7B;AACA;AACD,EArDa;;AAuDd;;;;;AAKAY,oBAAmB,2BAASb,EAAT,EAAa;AAC/BH,SAAOC,aAAP,CAAqBgB,IAArB,CAA0Bd,EAA1B;AACA,EA9Da;;AAgEd;;;AAGAe,uBAAsB,gCAAW;AAChClB,SAAOC,aAAP,GAAuB,EAAvB;AACA,EArEa;;AAuEd;;;AAGAkB,mBAAkB,4BAAW;AAC5BnB,SAAOC,aAAP,CAAqBmB,GAArB;AACA;AA5Ea,CAAf;;kBA+EepB,M","file":"SoyAop.js","sourcesContent":["'use strict';\n\nconst SoyAop = {\n\t/**\n\t * The functions that should be called instead of a template call. The last\n\t * function in the array is the one that is intercepting at the moment. If the\n\t * array is empty, the original function will be called instead.\n\t * @type {!Array<function()>}\n\t * @protected\n\t */\n\tinterceptFns_: [],\n\n\t/**\n\t * Gets the original function of the given template function. If no original exists,\n\t * returns the given function itself.\n\t * @param {!function()} fn\n\t * @return {!function()}\n\t */\n\tgetOriginalFn: function(fn) {\n\t\treturn fn.originalFn ? fn.originalFn : fn;\n\t},\n\n\t/**\n\t * Handles a template call, calling the current interception function if one\n\t * is set, or otherwise just calling the original function instead.\n\t * @param {!function()} originalFn The original template function that was\n\t *     intercepted.\n\t * @param {Object=} data Template data object.\n\t * @param {*=} ignored\n\t * @param {Object=} ijData Template injected data object.\n\t * @return {*} The return value of the function that is called to handle this\n\t *     interception.\n\t */\n\thandleTemplateCall_: function(originalFn, data, ignored, ijData) {\n\t\tconst interceptFn =\n\t\t\tSoyAop.interceptFns_[SoyAop.interceptFns_.length - 1]; // eslint-disable-line\n\t\tif (interceptFn) {\n\t\t\treturn interceptFn.call(null, originalFn, data, ignored, ijData);\n\t\t} else {\n\t\t\treturn originalFn.call(null, data, ignored, ijData);\n\t\t}\n\t},\n\n\t/**\n\t * Registers a template function that should be intercepted.\n\t * @param {!Object} templates The original templates object containing the\n\t *     function to be intercepted.\n\t * @param {string} name The name of the template function to intercept.\n\t */\n\tregisterForInterception: function(templates, name) {\n\t\tconst originalFn = templates[name];\n\t\tif (!originalFn.originalFn) {\n\t\t\ttemplates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);\n\t\t\ttemplates[name].originalFn = originalFn;\n\t\t}\n\t},\n\n\t/**\n\t * Starts intercepting all template calls, replacing them with a call to the\n\t * given function instead.\n\t * @param {!function()} fn\n\t */\n\tstartInterception: function(fn) {\n\t\tSoyAop.interceptFns_.push(fn);\n\t},\n\n\t/**\n\t * Stops intercepting template calls.\n\t */\n\tstopAllInterceptions: function() {\n\t\tSoyAop.interceptFns_ = [];\n\t},\n\n\t/**\n\t * Stops intercepting template calls with the last registered function.\n\t */\n\tstopInterception: function() {\n\t\tSoyAop.interceptFns_.pop();\n\t},\n};\n\nexport default SoyAop;\n"]}