{"version":3,"sources":["../src/IncrementalDomRenderer.js"],"names":["IncrementalDomRenderer","changes","props","component","data","ref","config","owner","components","childComponents","i","length","child","isDisposed","portalElement","element","dispose","key","node","dataOrElement","parent","COMPONENT_FLAG","patch","render","IncrementalDOM","elementVoid","shouldRender","wasRendered","shouldUpdate","currentPointer","willUpdate_","skipRender","context","refs","getInitialConfig","buildShouldUpdateArgs","skipNode","forceUpdate","informWillUpdate","constructor","renderer","RENDERER_NAME"],"mappings":"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","file":"IncrementalDomRenderer.js","sourcesContent":["'use strict';\n\nimport './incremental-dom';\nimport {getChanges, trackChanges} from './changes';\nimport {clearData, getData} from './data';\nimport {getOwner} from './children/children';\nimport {getPatchingComponent, patch} from './render/patch';\nimport {render, renderChild, renderFunction} from './render/render';\nimport {Component, ComponentRenderer} from 'metal-component';\n\nclass IncrementalDomRenderer extends ComponentRenderer.constructor {\n\t/**\n\t * Returns an array with the args that should be passed to the component's\n\t * `shouldUpdate` method. This can be overridden by sub classes to change\n\t * what the method should receive.\n\t * @param {Object} changes\n\t * @return {!Array}\n\t */\n\tbuildShouldUpdateArgs(changes) {\n\t\treturn [changes.props];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdispose(component) {\n\t\tconst data = getData(component);\n\t\tconst ref = data.config.ref;\n\t\tconst owner = data.owner;\n\t\tif (owner && owner.components && owner.components[ref] === component) {\n\t\t\tdelete owner.components[ref];\n\t\t}\n\n\t\tif (data.childComponents) {\n\t\t\tfor (let i = 0; i < data.childComponents.length; i++) {\n\t\t\t\tconst child = data.childComponents[i];\n\t\t\t\tif (!child.isDisposed()) {\n\t\t\t\t\tif (!child.portalElement) {\n\t\t\t\t\t\tchild.element = null;\n\t\t\t\t\t}\n\t\t\t\t\tchild.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclearData(component);\n\t}\n\n\t/**\n\t * Generates a key for the element currently being rendered in the given\n\t * component. By default, just returns the original key. Sub classes can\n\t * override this to change the behavior.\n\t * @param {!Component} component\n\t * @param {string} key\n\t * @return {?string}\n\t */\n\tgenerateKey(component, key) {\n\t\treturn key;\n\t}\n\n\t/**\n\t * Get the component's config data.\n\t * @param {!Component} component\n\t * @return {!Object}\n\t */\n\tgetConfig(component) {\n\t\treturn getData(component).config;\n\t}\n\n\t/**\n\t * Get the component's incremental dom renderer data.\n\t * @param {!Component} component\n\t * @return {!Object}\n\t */\n\tgetData(component) {\n\t\treturn getData(component);\n\t}\n\n\t/**\n\t * Gets the component that triggered the current patch operation.\n\t * @return {Component}\n\t */\n\tgetPatchingComponent() {\n\t\treturn getPatchingComponent();\n\t}\n\n\t/**\n\t * Handles a node having just been rendered. Sub classes should override this\n\t * for custom behavior.\n\t */\n\thandleNodeRendered() {}\n\n\t/**\n\t * Checks if the given object is an incremental dom node.\n\t * @param {!Object} node\n\t * @return {boolean}\n\t */\n\tisIncDomNode(node) {\n\t\treturn !!getOwner(node);\n\t}\n\n\t/**\n\t * Calls incremental dom's patch function to render the component.\n\t * @param {!Component} component\n\t */\n\tpatch(component) {\n\t\tpatch(component);\n\t}\n\n\t/**\n\t * Renders the renderer's component for the first time, patching its element\n\t * through incremental dom function calls. If the first arg is a function\n\t * instead of a component instance, creates and renders this function, which\n\t * can either be a simple incremental dom function or a component constructor.\n\t * @param {!Component|function()} component Can be a component instance, a\n\t *     simple incremental dom function or a component constructor.\n\t * @param {Object|Element=} dataOrElement Optional config data for the\n\t *     function, or parent for the rendered content.\n\t * @param {Element=} parent Optional parent for the rendered content.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\trender(component, dataOrElement, parent) {\n\t\tif (component[Component.COMPONENT_FLAG]) {\n\t\t\tthis.patch(component);\n\t\t} else {\n\t\t\treturn renderFunction(this, component, dataOrElement, parent);\n\t\t}\n\t}\n\n\t/**\n\t * Renders the given child node via its owner renderer.\n\t * @param {!Object} child\n\t */\n\trenderChild(child) {\n\t\trenderChild(child);\n\t}\n\n\t/**\n\t * Calls functions from `IncrementalDOM` to build the component element's\n\t * content. Can be overriden by subclasses (for integration with template\n\t * engines for example).\n\t * @param {!Component} component\n\t */\n\trenderIncDom(component) {\n\t\tif (component.render) {\n\t\t\tcomponent.render();\n\t\t} else {\n\t\t\tIncrementalDOM.elementVoid('div');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the incremental dom functions for rendering this component, without\n\t * calling `patch`. This function needs to be called inside a `patch`.\n\t * @param {!Component} component\n\t */\n\trenderInsidePatch(component) {\n\t\tconst changes = getChanges(component);\n\n\t\tconst shouldRender =\n\t\t\t!component.wasRendered ||\n\t\t\tthis.shouldUpdate(component, changes) ||\n\t\t\tIncrementalDOM.currentPointer() !== component.element;\n\t\tif (shouldRender) {\n\t\t\tthis.willUpdate_(component, changes);\n\n\t\t\trender(component);\n\t\t} else if (component.element) {\n\t\t\tthis.skipRender();\n\t\t}\n\t}\n\n\t/**\n\t * Sets up this component to be used by this renderer.\n\t * @param {!Component} component\n\t */\n\tsetUp(component) {\n\t\tcomponent.context = {};\n\t\tcomponent.components = {};\n\t\tcomponent.refs = {};\n\n\t\tconst data = getData(component);\n\t\tdata.config = component.getInitialConfig();\n\t\ttrackChanges(component);\n\t}\n\n\t/**\n\t * Checks if the component should be updated with the current state changes.\n\t * @param {!Component} component\n\t * @param {Object} changes\n\t * @return {boolean}\n\t */\n\tshouldUpdate(component, changes) {\n\t\tif (!changes) {\n\t\t\treturn false;\n\t\t}\n\t\tif (component.shouldUpdate) {\n\t\t\treturn component.shouldUpdate(\n\t\t\t\t...this.buildShouldUpdateArgs(changes)\n\t\t\t); // eslint-disable-line\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Skips the next disposal of children components, by clearing the array as\n\t * if there were no children rendered the last time. This can be useful for\n\t * allowing components to be reused by other parent components in separate\n\t * render update cycles.\n\t * @param {!Component} component\n\t */\n\tskipNextChildrenDisposal(component) {\n\t\tgetData(component).childComponents = null;\n\t}\n\n\t/**\n\t * Skips rendering the current node.\n\t */\n\tskipRender() {\n\t\tIncrementalDOM.skipNode();\n\t}\n\n\t/**\n\t * Updates the renderer's component when state changes, patching its element\n\t * through incremental dom function calls.\n\t * @param {!Component} component\n\t * @param {Object} data\n\t */\n\tupdate(component, data) {\n\t\tconst changes = getChanges(component);\n\t\tif (data.forceUpdate || this.shouldUpdate(component, changes)) {\n\t\t\tthis.willUpdate_(component, changes);\n\t\t\tthis.patch(component);\n\t\t}\n\t}\n\n\t/**\n\t * Invokes component's \"willUpdate\" lifecycle method if applicable.\n\t * @param {!Component} component\n\t * @param {Object} changes\n\t */\n\twillUpdate_(component, changes) {\n\t\tif (!component.wasRendered || !changes) {\n\t\t\treturn;\n\t\t}\n\t\tcomponent.informWillUpdate(...this.buildShouldUpdateArgs(changes));\n\t}\n}\n\nconst renderer = new IncrementalDomRenderer();\n\n// Name of this renderer. Renderers should provide this as a way to identify\n// them via a simple string (when calling enableCompatibilityMode to add\n// support to old features for specific renderers for example).\nrenderer.RENDERER_NAME = 'incremental-dom';\n\nexport default renderer;\n"]}