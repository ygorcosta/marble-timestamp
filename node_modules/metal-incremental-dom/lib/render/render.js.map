{"version":3,"sources":["../../src/render/render.js"],"names":["getComponentBeingRendered","isComponentTag_","render","renderChild","renderFunction","renderingComponents_","emptyChildren_","addElementClasses_","elementClasses","config","class","removeDuplicateClasses_","buildChildren_","children","length","cleanUpRender_","component","rootElementReached","element","informRendered","finishedRenderingComponent_","pop","generateKey_","key","data","getRenderer","generateKey","getChildComponents_","childComponents","getCurrentData","IncrementalDOM","currentElement","comp","obj","parentNode","get","icComponentsData","getRef_","owner","compatData","ownerRenderer","renderers","useKey","indexOf","RENDERER_NAME","ref","getSubComponent_","tagOrCtor","Ctor","getConstructor","match_","components","refs","type","currCount","prevComps","currComps","handleChildrenCaptured_","tree","props","tag","renderFromTag_","handleChildRender_","node","handleInterceptedAttributesCall_","name","value","handleInterceptedOpenCall_","handleSubComponentCall_","arguments","handleRegularCall_","args","getDataManager","call","resetNodeData_","updateElementIfNotReached_","handleNodeRendered","inheritElementClasses_","parent","parentData","parentConfig","currentClasses","toUpperCase","isMatch_","constructor","isDisposed","startSkipUpdates","replaceNonInternal","stopSkipUpdates","prepareRender_","push","resetComponentsData_","attributes","elementOpen","classString","classes","all","split","used","i","join","renderIncDom","child","prototype","renderSubComponent_","renderer","fnOrCtor","dataOrElement","isComponentCtor","fn","TempComponent","updateContext_","getInitialConfig","RENDERER","portalElement","renderInsidePatch","wasRendered","renderComponent","has","context","childContext","getChildContext","mixin"],"mappings":"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","file":"render.js","sourcesContent":["'use strict';\n\nimport {applyAttribute, convertListenerNamesToFns} from './attributes';\nimport {buildConfigFromCall, buildCallFromConfig} from '../callArgs';\nimport {\n\tcaptureChildren,\n\tgetOwner,\n\tisChildTag,\n\trenderChildTree,\n} from '../children/children';\nimport {clearChanges} from '../changes';\nimport {domData} from 'metal-dom';\nimport {getData} from '../data';\nimport {\n\tgetCompatibilityModeData,\n\tgetUid,\n\tisDef,\n\tisDefAndNotNull,\n\tisFunction,\n\tisServerSide,\n\tisString,\n\tobject,\n} from 'metal';\nimport {disposeUnused, schedule} from '../cleanup/unused';\nimport {\n\tgetOriginalFn,\n\tstartInterception,\n\tstopInterception,\n} from '../incremental-dom-aop';\nimport {Component, ComponentRegistry} from 'metal-component';\n\nconst renderingComponents_ = [];\nconst emptyChildren_ = [];\n\n/**\n * Adds the given css classes to the specified arguments for an incremental\n * dom call, merging with the existing value if there is one.\n * @param {string} elementClasses\n * @param {!Object} config\n * @private\n */\nfunction addElementClasses_(elementClasses, config) {\n\tif (config.class) {\n\t\tconfig.class += ` ${elementClasses}`;\n\t\tconfig.class = removeDuplicateClasses_(config.class);\n\t} else {\n\t\tconfig.class = elementClasses;\n\t}\n}\n\n/**\n * Builds the \"children\" array to be passed to the current component.\n * @param {!Array<!Object>} children\n * @return {!Array<!Object>}\n * @private\n */\nfunction buildChildren_(children) {\n\treturn children.length === 0 ? emptyChildren_ : children;\n}\n\n/**\n * Finishes the render operation, doing some cleaups.\n * @param {!Component} component\n * @private\n */\nfunction cleanUpRender_(component) {\n\tstopInterception();\n\tif (!getData(component).rootElementReached) {\n\t\tcomponent.element = null;\n\t}\n\tcomponent.informRendered();\n\tfinishedRenderingComponent_();\n}\n\n/**\n * Removes the most recent component from the queue of rendering components.\n * @private\n */\nfunction finishedRenderingComponent_() {\n\trenderingComponents_.pop();\n\tif (renderingComponents_.length === 0) {\n\t\tdisposeUnused();\n\t}\n}\n\n/**\n * Generates a key for the next element to be rendered.\n * @param {!Component} component\n * @param {?string} key The key originally passed to the element.\n * @return {?string}\n * @private\n */\nfunction generateKey_(component, key) {\n\tconst data = getData(component);\n\tif (!data.rootElementReached && data.config.key) {\n\t\tkey = data.config.key;\n\t}\n\treturn component.getRenderer().generateKey(component, key);\n}\n\n/**\n * Gets the child components stored in the given object.\n * @param {!Object} data\n * @return {!Array<!Component>}\n * @private\n */\nfunction getChildComponents_(data) {\n\tdata.childComponents = data.childComponents || [];\n\treturn data.childComponents;\n}\n\n/**\n * Gets the component being currently rendered.\n * @return {Component}\n */\nexport function getComponentBeingRendered() {\n\treturn renderingComponents_[renderingComponents_.length - 1];\n}\n\n/**\n * Gets the data object that should be currently used. This object will either\n * come from the current element being rendered by incremental dom or from\n * the component instance being rendered (only when the current element is the\n * component's direct parent).\n * @return {!Object}\n * @private\n */\nfunction getCurrentData() {\n\tconst element = IncrementalDOM.currentElement();\n\tconst comp = getComponentBeingRendered();\n\tlet obj = getData(comp);\n\tif (\n\t\tobj.rootElementReached &&\n\t\tcomp.element &&\n\t\telement !== comp.element.parentNode\n\t) {\n\t\tobj = domData.get(element);\n\t}\n\tobj.icComponentsData = obj.icComponentsData || {};\n\treturn obj.icComponentsData;\n}\n\n/**\n * Returns the \"ref\" to be used for a component. Uses \"key\" as \"ref\" when\n * compatibility mode is on for the current renderer.\n * @param {!Component} owner\n * @param {!Object} config\n * @return {?string}\n * @private\n */\nfunction getRef_(owner, config) {\n\tconst compatData = getCompatibilityModeData();\n\tif (compatData) {\n\t\tconst ownerRenderer = owner.getRenderer();\n\t\tconst renderers = compatData.renderers;\n\t\tconst useKey =\n\t\t\t!renderers ||\n\t\t\trenderers.indexOf(ownerRenderer) !== -1 ||\n\t\t\trenderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;\n\t\tif (useKey && config.key && !config.ref) {\n\t\t\treturn config.key;\n\t\t}\n\t}\n\treturn config.ref;\n}\n\n/**\n * Gets the sub component referenced by the given tag and config data,\n * creating it if it doesn't yet exist.\n * @param {string|!Function} tagOrCtor The tag name.\n * @param {!Object} config The config object for the sub component.\n * @param {!Component} owner\n * @return {!Component} The sub component.\n * @protected\n */\nfunction getSubComponent_(tagOrCtor, config, owner) {\n\tlet Ctor = tagOrCtor;\n\tif (isString(Ctor)) {\n\t\tCtor = ComponentRegistry.getConstructor(tagOrCtor);\n\t}\n\n\tconst ref = getRef_(owner, config);\n\tlet comp;\n\tif (isDef(ref)) {\n\t\tcomp = match_(owner.components[ref], Ctor, config, owner);\n\t\towner.components[ref] = comp;\n\t\towner.refs[ref] = comp;\n\t} else {\n\t\tconst data = getCurrentData();\n\t\tlet key = config.key;\n\t\tif (!isDef(key)) {\n\t\t\tconst type = getUid(Ctor, true);\n\t\t\tdata.currCount = data.currCount || {};\n\t\t\tdata.currCount[type] = data.currCount[type] || 0;\n\t\t\tkey = `__METAL_IC__${type}_${data.currCount[type]++}`;\n\t\t}\n\t\tcomp = match_(\n\t\t\tdata.prevComps ? data.prevComps[key] : null,\n\t\t\tCtor,\n\t\t\tconfig,\n\t\t\towner\n\t\t);\n\t\tdata.currComps = data.currComps || {};\n\t\tdata.currComps[key] = comp;\n\t}\n\n\treturn comp;\n}\n\n/**\n * Handles the event of children having finished being captured.\n * @param {!Object} tree The captured children in tree format.\n * @private\n * @return {Object}\n */\nfunction handleChildrenCaptured_(tree, {props, tag}) {\n\tprops.children = buildChildren_(tree.props.children);\n\treturn renderFromTag_(tag, props);\n}\n\n/**\n * Handles a child being rendered via `IncrementalDomChildren.render`. Skips\n * component nodes so that they can be rendered the correct way without\n * having to recapture both them and their children via incremental dom.\n * @param {!Object} node\n * @return {boolean}\n * @private\n */\nfunction handleChildRender_(node) {\n\tif (node.tag && isComponentTag_(node.tag)) {\n\t\tnode.props.children = buildChildren_(node.props.children);\n\t\trenderFromTag_(node.tag, node.props, getOwner(node));\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the attributes default handler from\n * incremental dom.\n * @param {!Element} element\n * @param {string} name\n * @param {*} value\n * @private\n */\nfunction handleInterceptedAttributesCall_(element, name, value) {\n\tapplyAttribute(getComponentBeingRendered(), element, name, value);\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {string} tag\n * @private\n * @return {Object}\n */\nfunction handleInterceptedOpenCall_(tag) {\n\tif (isComponentTag_(tag)) {\n\t\treturn handleSubComponentCall_(...arguments);\n\t} else {\n\t\treturn handleRegularCall_(...arguments);\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a regular element. Among other things, adds any inline\n * listeners found on the first render and makes sure that component root\n * elements are always reused.\n * @param {!Component} owner\n * @param {!Array} args\n * @return {!Element} The rendered element.\n * @private\n */\nfunction handleRegularCall_(...args) {\n\tconst config = buildConfigFromCall(args);\n\tlet tag = args[0];\n\n\tconst comp = getComponentBeingRendered();\n\tlet owner = comp;\n\tif (isChildTag(tag)) {\n\t\towner = tag.owner;\n\t\ttag = tag.tag;\n\t}\n\tconfig.key = generateKey_(comp, config.key);\n\n\tif (!getData(comp).rootElementReached) {\n\t\tconst elementClasses = comp\n\t\t\t.getDataManager()\n\t\t\t.get(comp, 'elementClasses');\n\t\tif (elementClasses) {\n\t\t\taddElementClasses_(elementClasses, config);\n\t\t}\n\t}\n\tconvertListenerNamesToFns(comp, config);\n\n\tconst call = buildCallFromConfig(tag, config);\n\tconst node = getOriginalFn('elementOpen')(...call);\n\tresetNodeData_(node);\n\tupdateElementIfNotReached_(comp, node);\n\n\tif (isDefAndNotNull(config.ref)) {\n\t\towner.refs[config.ref] = node;\n\t}\n\towner.getRenderer().handleNodeRendered(node);\n\n\treturn node;\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom, done for a sub component element. Creates and updates the appropriate\n * sub component.\n * @private\n */\nfunction handleSubComponentCall_(...args) {\n\tcaptureChildren(getComponentBeingRendered(), handleChildrenCaptured_, {\n\t\tprops: buildConfigFromCall(args),\n\t\ttag: args[0],\n\t});\n}\n\n/**\n * Passes down elementClasses to a child component if the parent component\n * returns another component at the top level (HOC).\n * @param {*} parent The parent component\n * @param {*} config The config of the subcomponent\n */\nfunction inheritElementClasses_(parent, config) {\n\tconst parentData = getData(parent);\n\tconst parentConfig = parentData.config;\n\n\tif (\n\t\t!parentData.rootElementReached &&\n\t\tparentConfig &&\n\t\tisString(parentConfig.elementClasses)\n\t) {\n\t\tlet currentClasses = '';\n\t\tif (isString(config.elementClasses)) {\n\t\t\tcurrentClasses = `${config.elementClasses} `;\n\t\t}\n\n\t\tconfig.elementClasses = currentClasses + parentConfig.elementClasses;\n\t}\n}\n\n/**\n * Checks if the given tag represents a metal component.\n * @param {string} tag\n * @return {boolean}\n * @private\n */\nexport function isComponentTag_(tag) {\n\treturn (\n\t\tisFunction(tag) || (isString(tag) && tag[0] === tag[0].toUpperCase())\n\t); // eslint-disable-line\n}\n\n/**\n * Checks if the given component can be a match for a constructor.\n * @param {!Component} comp\n * @param {!function()} Ctor\n * @param {!Component} owner\n * @return {boolean}\n * @private\n */\nfunction isMatch_(comp, Ctor, owner) {\n\tif (!comp || comp.constructor !== Ctor || comp.isDisposed()) {\n\t\treturn false;\n\t}\n\treturn getData(comp).owner === owner;\n}\n\n/**\n * Returns the given component if it matches the specified constructor\n * function. Otherwise, returns a new instance of the given constructor. On\n * both cases the component's state and config will be updated.\n * @param {Component} comp\n * @param {!function()} Ctor\n * @param {!Object} config\n * @param {!Component} owner\n * @return {!Component}\n * @private\n */\nfunction match_(comp, Ctor, config, owner) {\n\tif (isMatch_(comp, Ctor, owner)) {\n\t\tcomp.startSkipUpdates();\n\t\tcomp.getDataManager().replaceNonInternal(comp, config);\n\t\tcomp.stopSkipUpdates();\n\t} else {\n\t\tcomp = new Ctor(config, false);\n\t}\n\tgetData(comp).config = config;\n\treturn comp;\n}\n\n/**\n * Prepares the render operation, resetting the component's data and starting\n * the incremental dom interception.\n * @param {!Component} component\n * @private\n */\nfunction prepareRender_(component) {\n\trenderingComponents_.push(component);\n\n\tconst data = getData(component);\n\tresetComponentsData_(data.icComponentsData);\n\tclearChanges(data);\n\tdata.rootElementReached = false;\n\tcomponent.refs = {};\n\n\tif (data.childComponents) {\n\t\tschedule(data.childComponents);\n\t\tdata.childComponents = null;\n\t}\n\n\tstartInterception({\n\t\tattributes: handleInterceptedAttributesCall_,\n\t\telementOpen: handleInterceptedOpenCall_,\n\t});\n}\n\n/**\n * Removes duplicate css classes from the given string.\n * @param {string} classString\n * @return {string}\n * @private\n */\nfunction removeDuplicateClasses_(classString) {\n\tconst classes = [];\n\tconst all = classString.split(/\\s+/);\n\tconst used = {};\n\tfor (let i = 0; i < all.length; i++) {\n\t\tif (!used[all[i]]) {\n\t\t\tused[all[i]] = true;\n\t\t\tclasses.push(all[i]);\n\t\t}\n\t}\n\treturn classes.join(' ');\n}\n\n/**\n * Renders the component with incremental dom function calls. This assumes that\n * an incremental dom `patch` is already running, and that this function has\n * been called inside it.\n * @param {!Component} component\n */\nexport function render(component) {\n\tprepareRender_(component);\n\tcomponent.getRenderer().renderIncDom(component);\n\tcleanUpRender_(component);\n}\n\n/**\n * Renders the given child node.\n * @param {!Object} child\n */\nexport function renderChild(child) {\n\trenderChildTree(child, handleChildRender_);\n}\n\n/**\n * Renders the contents for the given tag.\n * @param {!function()|string} tag\n * @param {!Object} config\n * @param {Component=} owner\n * @private\n * @return {Object}\n */\nfunction renderFromTag_(tag, config, owner) {\n\tif (isString(tag) || tag.prototype.getRenderer) {\n\t\tconst comp = renderSubComponent_(tag, config, owner);\n\t\tupdateElementIfNotReached_(getComponentBeingRendered(), comp.element);\n\t\treturn comp.element;\n\t} else {\n\t\treturn tag(config);\n\t}\n}\n\n/**\n * Creates and renders the given function, which can either be a simple\n * incremental dom function or a component constructor.\n * @param {!IncrementalDomRenderer} renderer\n * @param {!function()} fnOrCtor Either a simple incremental dom function or a\n *     component constructor.\n * @param {Object|Element=} dataOrElement Optional config data for the\n *     function or parent for the rendered content.\n * @param {Element=} parent Optional parent for the rendered content.\n * @return {!Component} The rendered component's instance.\n */\nexport function renderFunction(renderer, fnOrCtor, dataOrElement, parent) {\n\tif (!Component.isComponentCtor(fnOrCtor)) {\n\t\tconst fn = fnOrCtor;\n\t\tclass TempComponent extends Component {\n\t\t\tcreated() {\n\t\t\t\tconst parent = getComponentBeingRendered();\n\t\t\t\tif (parent) {\n\t\t\t\t\tupdateContext_(this, parent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender() {\n\t\t\t\tfn(this.getInitialConfig());\n\t\t\t}\n\t\t}\n\t\tTempComponent.RENDERER = renderer;\n\t\tfnOrCtor = TempComponent;\n\t}\n\treturn Component.render(fnOrCtor, dataOrElement, parent);\n}\n\n/**\n * This updates the sub component that is represented by the given data.\n * The sub component is created, added to its parent and rendered. If it\n * had already been rendered before though, it will only have its state\n * updated instead.\n * @param {string|!function()} tagOrCtor The tag name or constructor function.\n * @param {!Object} config The config object for the sub component.\n * @param {ComponentRenderer=} owner\n * @return {!Component} The updated sub component.\n * @private\n */\nfunction renderSubComponent_(tagOrCtor, config, owner) {\n\tconst parent = getComponentBeingRendered();\n\towner = owner || parent;\n\n\tinheritElementClasses_(parent, config);\n\n\tconst comp = getSubComponent_(tagOrCtor, config, owner);\n\tupdateContext_(comp, parent);\n\n\tconst data = getData(comp);\n\tdata.parent = parent;\n\tdata.owner = owner;\n\n\tconst parentData = getData(parent);\n\tgetChildComponents_(parentData).push(comp);\n\tif (!config.key && !parentData.rootElementReached) {\n\t\tconfig.key = parentData.config.key;\n\t}\n\n\tif (comp.portalElement && isServerSide()) {\n\t\treturn comp;\n\t}\n\n\tif (!comp.portalElement) {\n\t\tcomp.getRenderer().renderInsidePatch(comp);\n\t}\n\n\tif (!comp.wasRendered) {\n\t\tcomp.renderComponent();\n\t}\n\treturn comp;\n}\n\n/**\n * Resets the given incremental dom data object, preparing it for the next pass.\n * @param {Object} data\n * @private\n */\nfunction resetComponentsData_(data) {\n\tif (data) {\n\t\tdata.prevComps = data.currComps;\n\t\tdata.currComps = null;\n\t\tdata.currCount = null;\n\t}\n}\n/**\n * Resets all data stored in the given node.\n * @param {!Element} node\n * @private\n */\nfunction resetNodeData_(node) {\n\tif (domData.has(node)) {\n\t\tresetComponentsData_(domData.get(node).icComponentsData);\n\t}\n}\n\n/**\n * Updates the given component's context according to the data from the\n * component that is currently being rendered.\n * @param {!Component} comp\n * @param {!Component} parent\n * @protected\n */\nfunction updateContext_(comp, parent) {\n\tconst context = comp.context;\n\tconst childContext = parent.getChildContext\n\t\t? parent.getChildContext()\n\t\t: null; // eslint-disable-line\n\tobject.mixin(context, parent.context, childContext);\n\tcomp.context = context;\n}\n\n/**\n * Updates this renderer's component's element with the given values, unless\n * it has already been reached by an earlier call.\n * @param {!Component} component\n * @param {!Element} node\n * @private\n */\nfunction updateElementIfNotReached_(component, node) {\n\tconst data = getData(component);\n\tif (!data.rootElementReached) {\n\t\tdata.rootElementReached = true;\n\t\tif (component.element !== node) {\n\t\t\tcomponent.element = node;\n\t\t}\n\t}\n}\n"]}