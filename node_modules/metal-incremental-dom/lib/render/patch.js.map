{"version":3,"sources":["../../src/render/patch.js"],"names":["getPatchingComponent","patch","patchingComponents_","buildParentIfNecessary_","element","parentNode","parent","document","createElement","callPatch_","component","outer","push","data","render","bind","patchFn","IncrementalDOM","patchOuter","pop","length","tryPatchEmptyWithParent_","tryPatchWithNoParent_","getRenderer","tempParent","inDocument","attach","getAttachData","attachElement","sibling"],"mappings":"AAAA;;;;;QAwDgBA,oB,GAAAA,oB;QAQAC,K,GAAAA,K;;AA9DhB;;AACA;;AACA;;AAEA,IAAMC,sBAAsB,EAA5B;;AAEA;;;;;;;;AAQA,SAASC,uBAAT,CAAiCC,OAAjC,EAA0C;AACzC,KAAI,CAACA,OAAD,IAAY,CAACA,QAAQC,UAAzB,EAAqC;AACpC,MAAIC,SAAS,EAAb;AACA,MAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;AACpCD,YAASC,SAASC,aAAT,CAAuB,KAAvB,CAAT;AACA;AACD,MAAIJ,OAAJ,EAAa;AACZ,yBAAOE,MAAP,EAAeF,OAAf;AACA;AACD,SAAOE,MAAP;AACA;AACD;;AAED;;;;;;;;AAQA,SAASG,UAAT,CAAoBC,SAApB,EAA+BN,OAA/B,EAAwCO,KAAxC,EAA+C;AAC9CT,qBAAoBU,IAApB,CAAyBF,SAAzB;;AAEA,KAAMG,OAAO,mBAAQH,SAAR,CAAb;AACA,KAAI,CAACG,KAAKC,MAAV,EAAkB;AACjB;AACAD,OAAKC,MAAL,GAAc,eAAOC,IAAP,CAAY,IAAZ,EAAkBL,SAAlB,CAAd;AACA;;AAED,KAAMM,UAAUL,QAAQM,eAAeC,UAAvB,GAAoCD,eAAehB,KAAnE;AACAe,SAAQZ,OAAR,EAAiBS,KAAKC,MAAtB;;AAEAZ,qBAAoBiB,GAApB;AACA;;AAED;;;;AAIO,SAASnB,oBAAT,GAAgC;AACtC,QAAOE,oBAAoBA,oBAAoBkB,MAApB,GAA6B,CAAjD,CAAP;AACA;;AAED;;;;AAIO,SAASnB,KAAT,CAAeS,SAAf,EAA0B;AAChC,KAAI,CAACW,yBAAyBX,SAAzB,CAAL,EAA0C;AACzC,MAAI,CAACY,sBAAsBZ,SAAtB,CAAL,EAAuC;AACtC,OAAMN,UAAUM,UAAUN,OAA1B;AACAK,cAAWC,SAAX,EAAsBN,OAAtB,EAA+B,IAA/B;AACA;AACD;AACD;;AAED;;;;;;;;AAQA,SAASiB,wBAAT,CAAkCX,SAAlC,EAA6C;AAC5C,KAAMG,OAAO,mBAAQH,SAAR,CAAb;AACA,KAAI,CAACA,UAAUN,OAAX,IAAsBS,KAAKP,MAA/B,EAAuC;AACtCO,OAAKP,MAAL,CAAYiB,WAAZ,GAA0BtB,KAA1B,CAAgCY,KAAKP,MAArC;AACA,SAAO,IAAP;AACA;AACD;;AAED;;;;;;;;;;AAUA,SAASgB,qBAAT,CAA+BZ,SAA/B,EAA0C;AACzC,KAAMc,aAAarB,wBAAwBO,UAAUN,OAAlC,CAAnB;AACA,KAAIoB,UAAJ,EAAgB;AACff,aAAWC,SAAX,EAAsBc,UAAtB;AACA,8BAAad,UAAUN,OAAvB;AACA,MAAIM,UAAUN,OAAV,IAAqBM,UAAUe,UAAnC,EAA+C;AAC9C,OAAMC,SAAShB,UAAUiB,aAAV,EAAf;AACAjB,aAAUkB,aAAV,CAAwBF,OAAOpB,MAA/B,EAAuCoB,OAAOG,OAA9C;AACA;AACD,SAAO,IAAP;AACA;AACD","file":"patch.js","sourcesContent":["'use strict';\n\nimport {append, exitDocument} from 'metal-dom';\nimport {getData} from '../data';\nimport {render} from './render';\n\nconst patchingComponents_ = [];\n\n/**\n * Guarantees that the component's element has a parent. That's necessary\n * when calling incremental dom's `patchOuter` for now, as otherwise it will\n * throw an error if the element needs to be replaced.\n * @param {Element} element\n * @return {Element} The parent, in case it was added.\n * @private\n */\nfunction buildParentIfNecessary_(element) {\n\tif (!element || !element.parentNode) {\n\t\tlet parent = {};\n\t\tif (typeof document !== 'undefined') {\n\t\t\tparent = document.createElement('div');\n\t\t}\n\t\tif (element) {\n\t\t\tappend(parent, element);\n\t\t}\n\t\treturn parent;\n\t}\n}\n\n/**\n * Calls incremental dom's patch function.\n * @param {!Component} component The component to patch.\n * @param {!Element} element The element the component should be patched on.\n * @param {boolean=} outer Flag indicating if `patchOuter` should be used\n *     instead of `patch`.\n * @private\n */\nfunction callPatch_(component, element, outer) {\n\tpatchingComponents_.push(component);\n\n\tconst data = getData(component);\n\tif (!data.render) {\n\t\t// Store reference to avoid binds on every patch.\n\t\tdata.render = render.bind(null, component);\n\t}\n\n\tconst patchFn = outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;\n\tpatchFn(element, data.render);\n\n\tpatchingComponents_.pop();\n}\n\n/**\n * Gets the component that triggered the current patch operation.\n * @return {Component}\n */\nexport function getPatchingComponent() {\n\treturn patchingComponents_[patchingComponents_.length - 1];\n}\n\n/**\n * Patches the component with incremental dom function calls.\n * @param {!Component} component\n */\nexport function patch(component) {\n\tif (!tryPatchEmptyWithParent_(component)) {\n\t\tif (!tryPatchWithNoParent_(component)) {\n\t\t\tconst element = component.element;\n\t\t\tcallPatch_(component, element, true);\n\t\t}\n\t}\n}\n\n/**\n * Checks if the component has no content but was rendered from another\n * component. If so, we'll need to patch this parent to make sure that any new\n * content will be added in the right position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchEmptyWithParent_(component) {\n\tconst data = getData(component);\n\tif (!component.element && data.parent) {\n\t\tdata.parent.getRenderer().patch(data.parent);\n\t\treturn true;\n\t}\n}\n\n/**\n * Checks if the component's element exists and has a parent. If that's not the\n * case, a temporary parent will be created and passed to the `patch` function,\n * since incremental dom requires it. Once the patch is done the temporary\n * parent is removed and the component's content is reattached to the correct\n * final position.\n * @param {!Component} component\n * @return {?boolean} True if the patch happened. Nothing otherwise.\n * @private\n */\nfunction tryPatchWithNoParent_(component) {\n\tconst tempParent = buildParentIfNecessary_(component.element);\n\tif (tempParent) {\n\t\tcallPatch_(component, tempParent);\n\t\texitDocument(component.element);\n\t\tif (component.element && component.inDocument) {\n\t\t\tconst attach = component.getAttachData();\n\t\t\tcomponent.attachElement(attach.parent, attach.sibling);\n\t\t}\n\t\treturn true;\n\t}\n}\n"]}