{"version":3,"sources":["../../src/children/children.js"],"names":["captureChildren","isChildTag","getOwner","renderChildTree","CHILD_OWNER","component","callback","data","owner_","callback_","callbackData_","tree_","props","children","config","currentParent_","isCapturing_","elementClose","handleInterceptedCloseCall_","elementOpen","handleInterceptedOpenCall_","text","handleInterceptedTextCall_","tag","node","tree","skipNode","addChildToTree","call","args","IncrementalDOM","apply","owner","i","length","addChildCallToTree_","isText","child","parent","push"],"mappings":"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","file":"children.js","sourcesContent":["'use strict';\n\nimport {buildCallFromConfig, buildConfigFromCall} from '../callArgs';\nimport {isDef} from 'metal';\nimport {startInterception, stopInterception} from '../incremental-dom-aop';\n\n/**\n * Property identifying a specific object as a Metal.js child node, and\n * pointing to the component instance that created it.\n * @type {string}\n */\nexport const CHILD_OWNER = '__metalChildOwner';\n\n/**\n * Captures all child elements from incremental dom calls.\n * @param {!Component} component The component that is capturing children.\n * @param {!function()} callback Function to be called when children have all\n *     been captured.\n * @param {Object} data Data to pass to the callback function when calling it.\n */\nexport function captureChildren(component, callback, data) {\n\towner_ = component;\n\tcallback_ = callback;\n\tcallbackData_ = data;\n\ttree_ = {\n\t\tprops: {\n\t\t\tchildren: [],\n\t\t},\n\t};\n\ttree_.config = tree_.props;\n\tcurrentParent_ = tree_;\n\tisCapturing_ = true;\n\tstartInterception({\n\t\telementClose: handleInterceptedCloseCall_,\n\t\telementOpen: handleInterceptedOpenCall_,\n\t\ttext: handleInterceptedTextCall_,\n\t});\n}\n\n/**\n * Checks if the given tag was built from a component's children.\n * @param {*} tag\n * @return {boolean}\n */\nexport function isChildTag(tag) {\n\treturn isDef(tag.tag);\n}\n\n/**\n * Gets the node's original owner.\n * @param {!Object} node\n * @return {Component}\n */\nexport function getOwner(node) {\n\treturn node[CHILD_OWNER];\n}\n\n/**\n * Renders a children tree through incremental dom.\n * @param {!{args: Array, children: !Array, isText: ?boolean}} tree\n * @param {function()=} skipNode Optional function that is called for\n *     each node to be rendered. If it returns true, the node will be skipped.\n * @protected\n */\nexport function renderChildTree(tree, skipNode) {\n\tif (isCapturing_) {\n\t\t// If capturing, just add the node directly to the captured tree.\n\t\taddChildToTree(tree);\n\t\treturn;\n\t}\n\n\tif (skipNode && skipNode.call(null, tree)) {\n\t\treturn;\n\t}\n\n\tif (isDef(tree.text)) {\n\t\tlet args = tree.args ? tree.args : [];\n\t\targs[0] = tree.text;\n\t\tIncrementalDOM.text.apply(null, args);\n\t} else {\n\t\tlet args = buildCallFromConfig(tree.tag, tree.props);\n\t\targs[0] = {\n\t\t\ttag: args[0],\n\t\t\towner: getOwner(tree),\n\t\t};\n\t\tIncrementalDOM.elementOpen.apply(null, args);\n\t\tif (tree.props.children) {\n\t\t\tfor (let i = 0; i < tree.props.children.length; i++) {\n\t\t\t\trenderChildTree(tree.props.children[i], skipNode);\n\t\t\t}\n\t\t}\n\t\tIncrementalDOM.elementClose(tree.tag);\n\t}\n}\n\nlet callbackData_;\nlet callback_;\nlet currentParent_;\nlet isCapturing_ = false;\nlet owner_;\nlet tree_;\n\n/**\n * Adds a child element to the tree.\n * @param {!Array} args The arguments passed to the incremental dom call.\n * @param {boolean=} isText Optional flag indicating if the child is a\n *     text element.\n * @protected\n * @return {Object}\n */\nfunction addChildCallToTree_(args, isText = false) {\n\tconst child = {\n\t\tparent: currentParent_,\n\t\t[CHILD_OWNER]: owner_,\n\t};\n\n\tif (isText) {\n\t\tchild.text = args[0];\n\t\tif (args.length > 1) {\n\t\t\tchild.args = args;\n\t\t}\n\t} else {\n\t\tchild.tag = args[0];\n\t\tchild.props = buildConfigFromCall(args);\n\t\tchild.props.children = [];\n\t\tchild.config = child.props;\n\t}\n\n\taddChildToTree(child);\n\treturn child;\n}\n\nfunction addChildToTree(child) {\n\tcurrentParent_.props.children.push(child);\n}\n\n/**\n * Handles an intercepted call to the `elementClose` function from incremental\n * dom.\n * @protected\n * @return {Element | boolean}\n */\nfunction handleInterceptedCloseCall_() {\n\tif (currentParent_ === tree_) {\n\t\tstopInterception();\n\t\tisCapturing_ = false;\n\t\tconst node = callback_.call(owner_, tree_, callbackData_);\n\t\tcallback_ = null;\n\t\tcallbackData_ = null;\n\t\tcurrentParent_ = null;\n\t\towner_ = null;\n\t\ttree_ = null;\n\t\treturn node;\n\t} else {\n\t\tcurrentParent_ = currentParent_.parent;\n\t\treturn true;\n\t}\n}\n\n/**\n * Handles an intercepted call to the `elementOpen` function from incremental\n * dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedOpenCall_(...args) {\n\tcurrentParent_ = addChildCallToTree_(args);\n}\n\n/**\n * Handles an intercepted call to the `text` function from incremental dom.\n * @param {!function()} originalFn The original function before interception.\n * @protected\n */\nfunction handleInterceptedTextCall_(...args) {\n\taddChildCallToTree_(args, true);\n}\n"]}