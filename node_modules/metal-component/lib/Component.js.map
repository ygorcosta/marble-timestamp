{"version":3,"sources":["../src/Component.js"],"names":["Component","config","parentElement","elementEventProxy_","proxyBlackList_","eventsStateKeyHandler_","forceUpdateCallback_","inDocument","initialConfig_","portalElement","wasRendered","DEFAULT_ELEMENT_PARENT","document","body","setShouldUseFacade","element","setUpRenderer_","setUpDataManager_","setUpSyncUpdates_","setUpPortal_","on","handleStateWillChange_","handleComponentStateChanged_","onEventsChanged_","addListenersFromObj_","dataManager_","get","created","componentCreated_","renderComponent","obj","handles","add","siblingElement","emit","willAttach","attachElement","attachData_","parent","sibling","attached","parentNode","insertBefore","eventName","selector","callback","willDetach","removeChild","detached","detach","disposed","dispose","renderer_","updateRenderer_","forceUpdate","portalElementSelector","indexOf","createElement","setAttribute","slice","getState","getStateKeys","prevVal","newVal","setOriginEmitter","syncVisible","event","hasSyncUpdates","changes","data","key","willReceiveState","syncUpdates_","firstRender","hasRendererRendered_","rendered","willUpdate","class1","class2","removeAllListeners","window","__METAL_DEV_TOOLS_HOOK__","getRenderer","render","attach","state","setState","val","elementClasses","constructor","mergeElementClasses_","trim","setUp","mixin","getExtraDataConfig","DATA","getPortalElement_","placeholder","appendChild","handleComponentStateKeyChanged_","bind","skipUpdates_","style","display","update","elementValue_","prev","handleComponentElementChanged_","fn","prototype","COMPONENT_FLAG","Ctor","configOrElement","instance","rendererName","RENDERER","RENDERER_NAME","IncrementalDOM","Error","interceptedComponentStrings","patch","patchInterceptor","currentElement","push","innerHTML","children","validator","Array","isArray","value","setter","events","visible","DATA_MANAGER","ELEMENT_CLASSES","SYNC_UPDATES","eventsChanged","stateChanged","stateKeyChanged"],"mappings":"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","file":"Component.js","sourcesContent":["'use strict';\n\nimport {addListenersFromObj} from './events/events';\nimport {\n\tgetStaticProperty,\n\tisBoolean,\n\tisDefAndNotNull,\n\tisElement,\n\tisObject,\n\tisServerSide,\n\tisString,\n\tobject,\n} from 'metal';\nimport {syncState} from './sync/sync';\nimport {DomEventEmitterProxy, enterDocument, toElement} from 'metal-dom';\nimport ComponentDataManager from './ComponentDataManager';\nimport ComponentRenderer from './ComponentRenderer';\nimport {EventEmitter, EventHandler} from 'metal-events';\n\n/**\n * Component collects common behaviors to be followed by UI components, such\n * as Lifecycle, CSS classes management, events encapsulation and support for\n * different types of rendering.\n * Rendering logic can be done by either:\n *     - Listening to the `render` event inside the `created` lifecycle function\n *       and adding the rendering logic to the listener.\n *     - Using an existing implementation of `ComponentRenderer` like `Soy`,\n *       and following its patterns.\n *     - Building your own implementation of a `ComponentRenderer`.\n * Specifying the renderer that will be used can be done by setting the RENDERER\n * static variable to the renderer's constructor function.\n *\n * Example:\n *\n * <code>\n * class CustomComponent extends Component {\n *   created() {\n *   }\n *\n *   rendered() {\n *   }\n *\n *   willAttach() {\n *   }\n *\n *   attached() {\n *   }\n *\n *   willReceiveState() {\n *   }\n *\n *   // willReceiveProps is only available in JSX components\n *   willReceiveProps() {\n *   }\n *\n *   shouldUpdate() {\n *   }\n *\n *   willUpdate() {\n *   }\n *\n *   willDetach() {\n *   }\n *\n *   detached() {\n *   }\n *\n *   disposed() {\n *   }\n * }\n *\n * CustomComponent.RENDERER = MyRenderer;\n *\n * CustomComponent.STATE = {\n *   title: { value: 'Title' },\n *   fontSize: { value: '10px' }\n * };\n * </code>\n *\n * @extends {State}\n */\nclass Component extends EventEmitter {\n\t/**\n\t * Constructor function for `Component`.\n\t * @param {Object=} config An object with the initial values for this\n\t *     component's state.\n\t * @param {boolean|string|Element=} parentElement The element where the\n\t *     component should be rendered. Can be given as a selector or an element.\n\t *     If `false` is passed, the component won't be rendered automatically\n\t *     after created.\n\t * @constructor\n\t */\n\tconstructor(config, parentElement) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Instance of `DomEventEmitterProxy` which proxies events from the component's\n\t\t * element to the component itself.\n\t\t * @type {!DomEventEmitterProxy}\n\t\t * @protected\n\t\t */\n\t\tthis.elementEventProxy_ = new DomEventEmitterProxy(\n\t\t\tnull,\n\t\t\tthis,\n\t\t\tproxyBlackList_\n\t\t);\n\n\t\t/**\n\t\t * The `EventHandler` instance for events attached from the `events` state key.\n\t\t * @type {EventHandler}\n\t\t * @protected\n\t\t */\n\t\tthis.eventsStateKeyHandler_ = null;\n\n\t\t/**\n\t\t * Stores the pending callback function for when `forceUpdate` is used\n\t\t * to trigger a rerender.\n\t\t * @type {?function}\n\t\t */\n\t\tthis.forceUpdateCallback_ = null;\n\n\t\t/**\n\t\t * Whether the element is in document.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.inDocument = false;\n\n\t\t/**\n\t\t * The initial config option passed to this constructor.\n\t\t * @type {!Object}\n\t\t * @protected\n\t\t */\n\t\tthis.initialConfig_ = config || {};\n\n\t\t/**\n\t\t * Indicates whether the component should be rendered as a Portal, outside\n\t\t * of the parent component.\n\t\t * @type {string|Element|boolean}\n\t\t */\n\t\tthis.portalElement = null;\n\n\t\t/**\n\t\t * Whether the element was rendered.\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.wasRendered = false;\n\n\t\t/**\n\t\t * The component's element will be appended to the element this variable is\n\t\t * set to, unless the user specifies another parent when calling `render` or\n\t\t * `attach`.\n\t\t * @type {!Element}\n\t\t */\n\t\tthis.DEFAULT_ELEMENT_PARENT =\n\t\t\ttypeof document !== 'undefined' ? document.body : null;\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.element = this.initialConfig_.element;\n\n\t\tthis.setUpRenderer_();\n\t\tthis.setUpDataManager_();\n\t\tthis.setUpSyncUpdates_();\n\n\t\tthis.setUpPortal_(this.initialConfig_.portalElement);\n\n\t\tthis.on('stateWillChange', this.handleStateWillChange_);\n\t\tthis.on('stateChanged', this.handleComponentStateChanged_);\n\t\tthis.on('eventsChanged', this.onEventsChanged_);\n\t\tthis.addListenersFromObj_(this.dataManager_.get(this, 'events'));\n\n\t\tthis.created();\n\t\tthis.componentCreated_ = true;\n\t\tif (parentElement !== false) {\n\t\t\tthis.renderComponent(parentElement);\n\t\t}\n\t}\n\n\t/**\n\t * Getter logic for the element property.\n\t * @return {Element}\n\t */\n\tget element() {\n\t\treturn this.elementValue_;\n\t}\n\n\t/**\n\t * Adds the listeners specified in the given object.\n\t * @param {!Object} obj\n\t * @protected\n\t */\n\taddListenersFromObj_(obj) {\n\t\tif (!this.eventsStateKeyHandler_) {\n\t\t\tthis.eventsStateKeyHandler_ = new EventHandler();\n\t\t}\n\t\tconst handles = addListenersFromObj(this, obj);\n\t\tthis.eventsStateKeyHandler_.add(...handles);\n\t}\n\n\t/**\n\t * Invokes the attached Lifecycle. When attached, the component element is\n\t * appended to the DOM and any other action to be performed must be\n\t * implemented in this method, such as, binding DOM events. A component can\n\t * be re-attached multiple times.\n\t * @param {(string|Element)=} parentElement Optional parent element\n\t *     to render the component.\n\t * @param {(string|Element)=} siblingElement Optional sibling element\n\t *     to render the component before it. Relevant when the component needs\n\t *     to be rendered before an existing element in the DOM.\n\t * @protected\n\t * @chainable\n\t * @return {Component}\n\t */\n\tattach(parentElement, siblingElement) {\n\t\tif (!this.inDocument) {\n\t\t\tthis.emit('willAttach');\n\t\t\tthis.willAttach();\n\t\t\tthis.attachElement(parentElement, siblingElement);\n\t\t\tthis.inDocument = true;\n\t\t\tthis.attachData_ = {\n\t\t\t\tparent: parentElement,\n\t\t\t\tsibling: siblingElement,\n\t\t\t};\n\t\t\tthis.emit('attached', this.attachData_);\n\t\t\tthis.attached();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lifecycle. When attached, the component element is appended to the DOM\n\t * and any other action to be performed must be implemented in this method,\n\t * such as, binding DOM events. A component can be re-attached multiple\n\t * times, therefore the undo behavior for any action performed in this phase\n\t * must be implemented on the detach phase.\n\t */\n\tattached() {}\n\n\t/**\n\t * Attaches the component element into the DOM.\n\t * @param {(string|Element)=} parentElement Optional parent element\n\t *     to render the component.\n\t * @param {(string|Element)=} siblingElement Optional sibling element\n\t *     to render the component before it. Relevant when the component needs\n\t *     to be rendered before an existing element in the DOM, e.g.\n\t *     `component.attach(null, existingElement)`.\n\t */\n\tattachElement(parentElement, siblingElement) {\n\t\tconst element = this.element;\n\t\tif (element && (siblingElement || !element.parentNode)) {\n\t\t\tconst parent =\n\t\t\t\ttoElement(parentElement) || this.DEFAULT_ELEMENT_PARENT; // eslint-disable-line\n\t\t\tparent.insertBefore(element, toElement(siblingElement));\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle. This is called when the component has just been created, before\n\t * it's rendered.\n\t */\n\tcreated() {}\n\n\t/**\n\t * Listens to a delegate event on the component's element.\n\t * @param {string} eventName The name of the event to listen to.\n\t * @param {string} selector The selector that matches the child elements that\n\t *   the event should be triggered for.\n\t * @param {!function(!Object)} callback Function to be called when the event is\n\t *   triggered. It will receive the normalized event object.\n\t * @return {!EventHandle} Can be used to remove the listener.\n\t */\n\tdelegate(eventName, selector, callback) {\n\t\treturn this.on(`delegate:${eventName}:${selector}`, callback);\n\t}\n\n\t/**\n\t * Invokes the detached Lifecycle. When detached, the component element is\n\t * removed from the DOM and any other action to be performed must be\n\t * implemented in this method, such as, unbinding DOM events. A component\n\t * can be detached multiple times.\n\t * @chainable\n\t * @return {Component}\n\t */\n\tdetach() {\n\t\tif (this.inDocument) {\n\t\t\tthis.emit('willDetach');\n\t\t\tthis.willDetach();\n\t\t\tif (this.element && this.element.parentNode) {\n\t\t\t\tthis.element.parentNode.removeChild(this.element);\n\t\t\t}\n\t\t\tthis.inDocument = false;\n\t\t\tthis.detached();\n\t\t}\n\t\tthis.emit('detached');\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lifecycle. When detached, the component element is removed from the DOM\n\t * and any other action to be performed must be implemented in this method,\n\t * such as, unbinding DOM events. A component can be detached multiple\n\t * times, therefore the undo behavior for any action performed in this phase\n\t * must be implemented on the attach phase.\n\t */\n\tdetached() {}\n\n\t/**\n\t * Lifecycle. Called when the component is disposed. Should be overridden by\n\t * sub classes to dispose of any internal data or events.\n\t */\n\tdisposed() {}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tthis.detach();\n\t\tthis.disposed();\n\t\tthis.emit('disposed');\n\n\t\tthis.elementEventProxy_.dispose();\n\t\tthis.elementEventProxy_ = null;\n\n\t\tthis.dataManager_.dispose(this);\n\t\tthis.dataManager_ = null;\n\n\t\tthis.renderer_.dispose(this);\n\t\tthis.renderer_ = null;\n\n\t\tsuper.disposeInternal();\n\t}\n\n\t/**\n\t * Forces an update that ignores the `shouldUpdate` lifecycle method for\n\t * components whose render depends on external variables.\n\t * @param {function()} callback\n\t */\n\tforceUpdate(callback) {\n\t\tthis.forceUpdateCallback_ = callback;\n\n\t\tthis.updateRenderer_({\n\t\t\tforceUpdate: true,\n\t\t});\n\t}\n\n\t/**\n\t * Gets data about where this component was attached at.\n\t * @return {!Object}\n\t */\n\tgetAttachData() {\n\t\treturn this.attachData_;\n\t}\n\n\t/**\n\t * Gets the `ComponentDataManager` being used.\n\t * @return {!ComponentDataManager}\n\t */\n\tgetDataManager() {\n\t\treturn this.dataManager_;\n\t}\n\n\t/**\n\t * Gets the configuration object that was passed to this component's constructor.\n\t * @return {!Object}\n\t */\n\tgetInitialConfig() {\n\t\treturn this.initialConfig_;\n\t}\n\n\t/**\n\t * Gets portalElement based on selector. If an id is passed and the element\n\t * does not exist, the element is created with that id and appended to the body.\n\t *\n\t * @param {string|Element} portalElementSelector\n\t * @return {?Element}\n\t */\n\tgetPortalElement_(portalElementSelector) {\n\t\tlet portalElement = toElement(portalElementSelector);\n\n\t\tif (portalElement) {\n\t\t\treturn portalElement;\n\t\t}\n\n\t\tif (\n\t\t\tportalElementSelector.indexOf('#') === 0 &&\n\t\t\tportalElementSelector.indexOf(' ') === -1\n\t\t) {\n\t\t\tportalElement = document.createElement('div');\n\t\t\tportalElement.setAttribute('id', portalElementSelector.slice(1));\n\n\t\t\tenterDocument(portalElement);\n\t\t}\n\n\t\treturn portalElement;\n\t}\n\n\t/**\n\t * Gets state data for this component.\n\t * @return {!Object}\n\t */\n\tgetState() {\n\t\treturn this.dataManager_.getState(this);\n\t}\n\n\t/**\n\t * Gets the keys for the state data.\n\t * @return {!Array<string>}\n\t */\n\tgetStateKeys() {\n\t\treturn this.dataManager_.getStateKeys(this);\n\t}\n\n\t/**\n\t * Gets the `ComponentRenderer` instance being used.\n\t * @return {!ComponentRenderer}\n\t */\n\tgetRenderer() {\n\t\treturn this.renderer_;\n\t}\n\n\t/**\n\t * Handles a change in the component's element.\n\t * @param {Element} prevVal\n\t * @param {Element} newVal\n\t * @protected\n\t */\n\thandleComponentElementChanged_(prevVal, newVal) {\n\t\tthis.elementEventProxy_.setOriginEmitter(newVal);\n\t\tif (this.componentCreated_) {\n\t\t\tthis.emit('elementChanged', {\n\t\t\t\tprevVal,\n\t\t\t\tnewVal,\n\t\t\t});\n\t\t\tif (newVal && this.wasRendered) {\n\t\t\t\tthis.syncVisible(this.dataManager_.get(this, 'visible'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles state batch changes. Calls any existing `sync` functions that\n\t * match the changed state keys.\n\t * @param {Event} event\n\t * @protected\n\t */\n\thandleComponentStateChanged_(event) {\n\t\tif (!this.hasSyncUpdates()) {\n\t\t\tthis.updateRenderer_(event);\n\t\t}\n\t\tsyncState(this, event.changes);\n\t\tthis.emit('stateSynced', event);\n\t}\n\n\t/**\n\t * Handles a `stateKeyChanged` event. This is only called for components that\n\t * have requested updates to happen synchronously.\n\t * @param {!{key: string, newVal: *, prevVal: *}} data\n\t * @protected\n\t */\n\thandleComponentStateKeyChanged_(data) {\n\t\tthis.updateRenderer_({\n\t\t\tchanges: {\n\t\t\t\t[data.key]: data,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Fires before state batch changes. Provides hook point for modifying\n\t *     state.\n\t * @param {Event} event\n\t * @protected\n\t */\n\thandleStateWillChange_(event) {\n\t\tthis.willReceiveState(event.changes);\n\t}\n\n\t/**\n\t * Checks if this component has sync updates enabled.\n\t * @return {boolean}\n\t */\n\thasSyncUpdates() {\n\t\treturn this.syncUpdates_;\n\t}\n\n\t/**\n\t * Informs that the component that the rendered has finished rendering it. The\n\t * renderer is the one responsible for calling this when appropriate. This\n\t * will emit events and run the appropriate lifecycle for the first render.\n\t */\n\tinformRendered() {\n\t\tconst firstRender = !this.hasRendererRendered_;\n\t\tthis.hasRendererRendered_ = true;\n\n\t\tif (this.forceUpdateCallback_) {\n\t\t\tthis.forceUpdateCallback_();\n\t\t\tthis.forceUpdateCallback_ = null;\n\t\t}\n\n\t\tthis.rendered(firstRender);\n\t\tthis.emit('rendered', firstRender);\n\t}\n\n\t/**\n\t * Informs the component that the renderer is about to update. Calls the\n\t * component's `willUpdate` lifecycle method.\n\t * @param {Object} changes\n\t */\n\tinformWillUpdate(...args) {\n\t\tthis.willUpdate(...args);\n\t}\n\n\t/**\n\t * Checks if the given function is a component constructor.\n\t * @param {!function()} fn Any function\n\t * @return {boolean}\n\t */\n\tstatic isComponentCtor(fn) {\n\t\treturn fn.prototype && fn.prototype[Component.COMPONENT_FLAG];\n\t}\n\n\t/**\n\t * Merges two values for the ELEMENT_CLASSES property into a single one.\n\t * @param {string} class1\n\t * @param {string} class2\n\t * @return {string} The merged value.\n\t * @protected\n\t */\n\tmergeElementClasses_(class1, class2) {\n\t\treturn class1 ? class1 + ' ' + (class2 || '') : class2;\n\t}\n\n\t/**\n\t * Fired when the `events` state value is changed.\n\t * @param {!Object} event\n\t * @protected\n\t */\n\tonEventsChanged_(event) {\n\t\tthis.eventsStateKeyHandler_.removeAllListeners();\n\t\tthis.addListenersFromObj_(event.newVal);\n\t}\n\n\t/**\n\t * Creates and renders a component for the given constructor function. This\n\t * will always make sure that the constructor runs without rendering the\n\t * component, having the `render` step happen only after it has finished.\n\t * @param {!function()} Ctor The component's constructor function.\n\t * @param {Object|Element=} configOrElement Optional config data or parent\n\t *     for the component.\n\t * @param {Element=} element Optional parent for the component.\n\t * @return {!Component} The rendered component's instance.\n\t */\n\tstatic render(Ctor, configOrElement, element) {\n\t\tlet config = configOrElement;\n\t\tif (isElement(configOrElement)) {\n\t\t\tconfig = null;\n\t\t\telement = configOrElement;\n\t\t}\n\t\tconst instance = new Ctor(config, false);\n\t\tinstance.renderComponent(element);\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Creates and renders a component for the given constructor function as\n\t * string. This will always make sure that the constructor runs without\n\t * rendering the component, having the `render` step happen only after it\n\t * has finished.\n\t * @param {!function()} Ctor The component's constructor function.\n\t * @param {Object|Element=} configOrElement Optional config data or\n\t *     parent for the component.\n\t * @return {!String} The rendered component's content as string.\n\t */\n\tstatic renderToString(Ctor, configOrElement) {\n\t\tconst rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;\n\t\tswitch (rendererName) {\n\t\tcase 'jsx':\n\t\tcase 'soy':\n\t\tcase 'incremental-dom': {\n\t\t\tif (typeof IncrementalDOM === 'undefined') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Error. Trying to render incremental dom ` +\n\t\t\t\t\t\t\t`based component to string requires IncrementalDOM ` +\n\t\t\t\t\t\t\t`implementation to be loaded.`\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Incremental dom patches for components or nested components are\n\t\t\t// isolated inside the component element. The following code intercepts\n\t\t\t// incremental dom patches and collect results into temporary stack in\n\t\t\t// order to successfully collect the final string of the outermost\n\t\t\t// component after all nested components stack rendered.\n\t\t\tconst interceptedComponentStrings = [];\n\t\t\tconst patch = IncrementalDOM.patch;\n\t\t\tconst patchInterceptor = function(...args) {\n\t\t\t\tlet currentElement = patch(...args);\n\t\t\t\tinterceptedComponentStrings.push(currentElement.innerHTML);\n\t\t\t\tIncrementalDOM.patch = patch;\n\t\t\t};\n\t\t\tIncrementalDOM.patch = patchInterceptor;\n\t\t\tComponent.render(Ctor, configOrElement).dispose();\n\t\t\treturn interceptedComponentStrings[0];\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(\n\t\t\t\t`Error. Trying to render non incremental dom ` +\n\t\t\t\t\t\t`based component to string.`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Renders the component into the DOM via its `ComponentRenderer`. Stores the\n\t * given parent element to be used when the renderer is done (`informRendered`).\n\t * @param {(string|Element|boolean)=} parentElement Optional parent element\n\t *     to render the component. If set to `false`, the element won't be\n\t *     attached to any element after rendering. In this case, `attach` should\n\t *     be called manually later to actually attach it to the dom.\n\t */\n\trenderComponent(parentElement) {\n\t\tif (!this.hasRendererRendered_) {\n\t\t\tif (!isServerSide() && window.__METAL_DEV_TOOLS_HOOK__) {\n\t\t\t\twindow.__METAL_DEV_TOOLS_HOOK__(this);\n\t\t\t}\n\t\t\tthis.getRenderer().render(this);\n\t\t}\n\t\tthis.emit('render');\n\t\tsyncState(this);\n\t\tthis.attach(parentElement);\n\t\tthis.wasRendered = true;\n\t}\n\n\t/**\n\t * Setter logic for the element property.\n\t * @param {?string|Element} val\n\t */\n\tset element(val) {\n\t\tif (!isElement(val) && !isString(val) && isDefAndNotNull(val)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (val) {\n\t\t\tval = toElement(val) || this.elementValue_;\n\t\t}\n\n\t\tif (this.elementValue_ !== val) {\n\t\t\tconst prev = this.elementValue_;\n\t\t\tthis.elementValue_ = val;\n\t\t\tthis.handleComponentElementChanged_(prev, val);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of all the specified state keys.\n\t * @param {!Object.<string,*>} state A map of state keys to the values they\n\t *   should be set to.\n\t * @param {function()=} callback An optional function that will be run\n\t *   after the next batched update is triggered.\n\t */\n\tsetState(state, callback) {\n\t\tthis.dataManager_.setState(this, state, callback);\n\t}\n\n\t/**\n\t * Setter for the `elementClasses` data property. Appends given value with\n\t * the one specified in `ELEMENT_CLASSES`.\n\t * @param {string} val\n\t * @return {string}\n\t * @protected\n\t */\n\tsetterElementClassesFn_(val) {\n\t\tconst elementClasses = getStaticProperty(\n\t\t\tthis.constructor,\n\t\t\t'ELEMENT_CLASSES',\n\t\t\tthis.mergeElementClasses_\n\t\t);\n\t\tif (elementClasses) {\n\t\t\tval += ` ${elementClasses}`;\n\t\t}\n\t\treturn val.trim();\n\t}\n\n\t/**\n\t * Sets up the component's data manager.\n\t * @protected\n\t */\n\tsetUpDataManager_() {\n\t\tthis.dataManager_ = getStaticProperty(this.constructor, 'DATA_MANAGER');\n\t\tthis.dataManager_.setUp(\n\t\t\tthis,\n\t\t\tobject.mixin(\n\t\t\t\t{},\n\t\t\t\tthis.renderer_.getExtraDataConfig(this),\n\t\t\t\tComponent.DATA\n\t\t\t) // eslint-disable-line\n\t\t);\n\t}\n\n\t/**\n\t * Overwrites element property if portalElement is passed. Creates\n\t * a nested placeholder so that portalElement is not removed from the\n\t * DOM when component first renders. When portalElement is equal to true,\n\t * component is appeneded to the body.\n\t *\n\t * @param {string|Element|boolean} portalElement\n\t */\n\tsetUpPortal_(portalElement) {\n\t\tif (\n\t\t\t!portalElement ||\n\t\t\t(!isElement(portalElement) &&\n\t\t\t\t!isString(portalElement) &&\n\t\t\t\t!isBoolean(portalElement))\n\t\t) {\n\t\t\treturn;\n\t\t} else if (isBoolean(portalElement) && portalElement) {\n\t\t\tportalElement = 'body';\n\t\t}\n\n\t\tif (isServerSide()) {\n\t\t\tthis.portalElement = true;\n\t\t\treturn;\n\t\t}\n\n\t\tportalElement = this.getPortalElement_(portalElement);\n\n\t\tif (portalElement) {\n\t\t\tconst placeholder = document.createElement('div');\n\n\t\t\tportalElement.appendChild(placeholder);\n\n\t\t\tthis.element = placeholder;\n\t\t\tthis.portalElement = portalElement;\n\t\t}\n\t}\n\n\t/**\n\t * Sets up the component's renderer.\n\t * @protected\n\t */\n\tsetUpRenderer_() {\n\t\tthis.renderer_ = getStaticProperty(this.constructor, 'RENDERER');\n\t\tthis.renderer_.setUp(this);\n\t}\n\n\t/**\n\t * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.\n\t * @protected\n\t */\n\tsetUpSyncUpdates_() {\n\t\tthis.syncUpdates_ = getStaticProperty(this.constructor, 'SYNC_UPDATES');\n\t\tif (this.hasSyncUpdates()) {\n\t\t\tthis.on(\n\t\t\t\t'stateKeyChanged',\n\t\t\t\tthis.handleComponentStateKeyChanged_.bind(this)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Skips renderer updates until `stopSkipUpdates` is called.\n\t */\n\tstartSkipUpdates() {\n\t\tthis.skipUpdates_ = true;\n\t}\n\n\t/**\n\t * Stops skipping renderer updates.\n\t */\n\tstopSkipUpdates() {\n\t\tthis.skipUpdates_ = false;\n\t}\n\n\t/**\n\t * State synchronization logic for `visible` state key.\n\t * Updates the element's display value according to its visibility.\n\t * @param {boolean} newVal\n\t */\n\tsyncVisible(newVal) {\n\t\tif (this.element) {\n\t\t\tthis.element.style.display = newVal ? '' : 'none';\n\t\t}\n\t}\n\n\t/**\n\t * Lifecycle. Called whenever the component has just been rendered.\n\t * @param {boolean} firstRender Flag indicating if this was the component's\n\t *     first render.\n\t */\n\trendered() {}\n\n\t/**\n\t * Calls \"update\" on the renderer, passing it the changed data.\n\t * @param {!{changes: !Object}} data\n\t * @protected\n\t */\n\tupdateRenderer_(data) {\n\t\tif (!data.forceUpdate) {\n\t\t\tthis.forceUpdateCallback_ = null;\n\t\t}\n\n\t\tif (!this.skipUpdates_ && this.hasRendererRendered_) {\n\t\t\tthis.getRenderer().update(this, data);\n\t\t}\n\t}\n\n\t/**\n\t * Validator logic for the `events` state key.\n\t * @param {Object} val\n\t * @return {boolean}\n\t * @protected\n\t */\n\tvalidatorEventsFn_(val) {\n\t\treturn !isDefAndNotNull(val) || isObject(val);\n\t}\n\n\t/**\n\t * Lifecycle. Fires before the component has been attached to the DOM.\n\t */\n\twillAttach() {}\n\n\t/**\n\t * Lifecycle. Fires before component is detached from the DOM.\n\t */\n\twillDetach() {}\n\n\t/**\n\t * Lifecycle. Called when the component is about to receive state changes.\n\t * Provides a hook point for modifying state that can be used in the next\n\t * rerender.\n\t * @param {Object} changes Changes made to this.state\n\t */\n\twillReceiveState() {}\n\n\t/**\n\t * Lifecycle. Called when the component's renderer is about to update.\n\t * @param {Object} changes\n\t */\n\twillUpdate() {}\n}\n\n/**\n * Component data definition.\n * @type {Object}\n * @static\n */\nComponent.DATA = {\n\t/**\n\t * Objects describing children elements that were passed to be rendered inside\n\t * this component.\n\t * @type {!Array<!Object>}\n\t */\n\tchildren: {\n\t\tvalidator: Array.isArray,\n\t\tvalue: [],\n\t},\n\n\t/**\n\t * CSS classes to be applied to the element.\n\t * @type {string}\n\t */\n\telementClasses: {\n\t\tsetter: 'setterElementClassesFn_',\n\t\tvalidator: isString,\n\t\tvalue: '',\n\t},\n\n\t/**\n\t * Listeners that should be attached to this component. Should be provided as\n\t * an object, where the keys are event names and the values are the listener\n\t * functions (or function names).\n\t * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}\n\t */\n\tevents: {\n\t\tvalidator: 'validatorEventsFn_',\n\t\tvalue: null,\n\t},\n\n\t/**\n\t * Indicates if the component is visible or not.\n\t * @type {boolean}\n\t */\n\tvisible: {\n\t\tvalidator: isBoolean,\n\t\tvalue: true,\n\t},\n};\n\n/**\n * Name of the flag used to identify component constructors via their prototype.\n * @type {string}\n */\nComponent.COMPONENT_FLAG = '__metal_component__';\n\n/**\n * The `ComponentDataManager` class that should be used. This class will be\n * responsible for handling the component's data. Each component may have its\n * own implementation.\n * @type {!ComponentDataManager}\n */\nComponent.DATA_MANAGER = ComponentDataManager;\n\n/**\n * CSS classes to be applied to the element.\n * @type {string}\n */\nComponent.ELEMENT_CLASSES = '';\n\n/**\n * The `ComponentRenderer` that should be used. Components need to set this\n * to a subclass of `ComponentRenderer` that has the rendering logic, like\n * `SoyRenderer`.\n * @type {!ComponentRenderer}\n */\nComponent.RENDERER = ComponentRenderer;\n\n/**\n * Flag indicating if component updates will happen synchronously. Updates are\n * done asynchronously by default, which allows changes to be batched and\n * applied together.\n * @type {boolean}\n */\nComponent.SYNC_UPDATES = false;\n\n/**\n * Sets a prototype flag to easily determine if a given constructor is for\n * a component or not.\n */\nComponent.prototype[Component.COMPONENT_FLAG] = true;\n\nconst proxyBlackList_ = {\n\teventsChanged: true,\n\tstateChanged: true,\n\tstateKeyChanged: true,\n};\n\nexport default Component;\n"]}